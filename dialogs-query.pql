PROCEDURE      DIALOGS.QUERY:T  (157417,64366)  |Last amended Oct 11, 2013,17:52:46
|| Generated by DP - don't edit anything outside |{...|}

|{ Header
call sysproc.tools.htmlcode  |sets html globals
| Creator:   Greg Neils
| Created:   August in 2008
| Updated:   8/8/2008, 8/2009
| Retired:
| Called by: Toolbar and other database buttons
| Calls:     every member in the SEARCH family
| Reason:    Everything you need to know about data in 1 nice spot
| Output:    Options to send output to an outside HTML file named after user.
c
program |crwarn
c
c print back noremarks nocommands
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 REP_TITLE                       ; preset REP_TITLE                         (1 )
integer*1 ARECN                           ; preset ARECN                            (2 )
integer*1 ARECL                           ; preset ARECL                            (3 )
integer*1 ID_00028                        ; preset ID_00028                         (4 )
integer*1 A1_ADD                          ; preset A1_ADD                           (5 )
integer*1 A1VARN                          ; preset A1VARN                           (6 )
integer*1 A1VARL                          ; preset A1VARL                           (7 )
integer*1 A1SIGNA                         ; preset A1SIGNA                          (8 )
integer*1 A1VALA                          ; preset A1VALA                           (9 )
integer*1 A1VALL                          ; preset A1VALL                           (10 )
integer*1 A1AND                           ; preset A1AND                            (11 )
integer*1 A1SIGNB                         ; preset A1SIGNB                          (12 )
integer*1 A1VALB                          ; preset A1VALB                           (13 )
integer*1 A2_ADD                          ; preset A2_ADD                           (14 )
integer*1 A2VARN                          ; preset A2VARN                           (15 )
integer*1 A2VARL                          ; preset A2VARL                           (16 )
integer*1 A2SIGNA                         ; preset A2SIGNA                          (17 )
integer*1 A2VALA                          ; preset A2VALA                           (18 )
integer*1 A2VALL                          ; preset A2VALL                           (19 )
integer*1 A2AND                           ; preset A2AND                            (20 )
integer*1 A2SIGNB                         ; preset A2SIGNB                          (21 )
integer*1 A2VALB                          ; preset A2VALB                           (22 )
integer*1 A3_ADD                          ; preset A3_ADD                           (23 )
integer*1 A3VARN                          ; preset A3VARN                           (24 )
integer*1 A3VARL                          ; preset A3VARL                           (25 )
integer*1 A3SIGNA                         ; preset A3SIGNA                          (26 )
integer*1 A3VALA                          ; preset A3VALA                           (27 )
integer*1 A3VALL                          ; preset A3VALL                           (28 )
integer*1 A3AND                           ; preset A3AND                            (29 )
integer*1 A3SIGNB                         ; preset A3SIGNB                          (30 )
integer*1 A3VALB                          ; preset A3VALB                           (31 )
integer*1 A4_ADD                          ; preset A4_ADD                           (32 )
integer*1 A4VARN                          ; preset A4VARN                           (33 )
integer*1 A4VARL                          ; preset A4VARL                           (34 )
integer*1 A4SIGNA                         ; preset A4SIGNA                          (35 )
integer*1 A4VALA                          ; preset A4VALA                           (36 )
integer*1 A4VALL                          ; preset A4VALL                           (37 )
integer*1 A4AND                           ; preset A4AND                            (38 )
integer*1 A4SIGNB                         ; preset A4SIGNB                          (39 )
integer*1 A4VALB                          ; preset A4VALB                           (40 )
integer*1 A5_ADD                          ; preset A5_ADD                           (41 )
integer*1 A5VARN                          ; preset A5VARN                           (42 )
integer*1 A5VARL                          ; preset A5VARL                           (43 )
integer*1 A5SIGNA                         ; preset A5SIGNA                          (44 )
integer*1 A5VALA                          ; preset A5VALA                           (45 )
integer*1 A5VALL                          ; preset A5VALL                           (46 )
integer*1 A5AND                           ; preset A5AND                            (47 )
integer*1 A5SIGNB                         ; preset A5SIGNB                          (48 )
integer*1 A5VALB                          ; preset A5VALB                           (49 )
integer*1 BRECN                           ; preset BRECN                            (50 )
integer*1 BRECL                           ; preset BRECL                            (51 )
integer*1 B1_ADD                          ; preset B1_ADD                           (52 )
integer*1 B1VARN                          ; preset B1VARN                           (53 )
integer*1 B1VARL                          ; preset B1VARL                           (54 )
integer*1 B1SIGNA                         ; preset B1SIGNA                          (55 )
integer*1 B1VALA                          ; preset B1VALA                           (56 )
integer*1 B1VALL                          ; preset B1VALL                           (57 )
integer*1 B1AND                           ; preset B1AND                            (58 )
integer*1 B1SIGNB                         ; preset B1SIGNB                          (59 )
integer*1 B1VALB                          ; preset B1VALB                           (60 )
integer*1 B2_ADD                          ; preset B2_ADD                           (61 )
integer*1 B2VARN                          ; preset B2VARN                           (62 )
integer*1 B2VARL                          ; preset B2VARL                           (63 )
integer*1 B2SIGNA                         ; preset B2SIGNA                          (64 )
integer*1 B2VALA                          ; preset B2VALA                           (65 )
integer*1 B2VALL                          ; preset B2VALL                           (66 )
integer*1 B2AND                           ; preset B2AND                            (67 )
integer*1 B2SIGNB                         ; preset B2SIGNB                          (68 )
integer*1 B2VALB                          ; preset B2VALB                           (69 )
integer*1 B3_ADD                          ; preset B3_ADD                           (70 )
integer*1 B3VARN                          ; preset B3VARN                           (71 )
integer*1 B3VARL                          ; preset B3VARL                           (72 )
integer*1 B3SIGNA                         ; preset B3SIGNA                          (73 )
integer*1 B3VALA                          ; preset B3VALA                           (74 )
integer*1 B3VALL                          ; preset B3VALL                           (75 )
integer*1 B3AND                           ; preset B3AND                            (76 )
integer*1 B3SIGNB                         ; preset B3SIGNB                          (77 )
integer*1 B3VALB                          ; preset B3VALB                           (78 )
integer*1 B4_ADD                          ; preset B4_ADD                           (79 )
integer*1 B4VARN                          ; preset B4VARN                           (80 )
integer*1 B4VARL                          ; preset B4VARL                           (81 )
integer*1 B4SIGNA                         ; preset B4SIGNA                          (82 )
integer*1 B4VALA                          ; preset B4VALA                           (83 )
integer*1 B4VALL                          ; preset B4VALL                           (84 )
integer*1 B4AND                           ; preset B4AND                            (85 )
integer*1 B4SIGNB                         ; preset B4SIGNB                          (86 )
integer*1 B4VALB                          ; preset B4VALB                           (87 )
integer*1 B5_ADD                          ; preset B5_ADD                           (88 )
integer*1 B5VARN                          ; preset B5VARN                           (89 )
integer*1 B5VARL                          ; preset B5VARL                           (90 )
integer*1 B5SIGNA                         ; preset B5SIGNA                          (91 )
integer*1 B5VALA                          ; preset B5VALA                           (92 )
integer*1 B5VALL                          ; preset B5VALL                           (93 )
integer*1 B5AND                           ; preset B5AND                            (94 )
integer*1 B5SIGNB                         ; preset B5SIGNB                          (95 )
integer*1 B5VALB                          ; preset B5VALB                           (96 )
integer*1 CRECN                           ; preset CRECN                            (97 )
integer*1 CRECL                           ; preset CRECL                            (98 )
integer*1 C1_ADD                          ; preset C1_ADD                           (99 )
integer*1 C1VARN                          ; preset C1VARN                           (100 )
integer*1 C1VARL                          ; preset C1VARL                           (101 )
integer*1 C1SIGNA                         ; preset C1SIGNA                          (102 )
integer*1 C1VALA                          ; preset C1VALA                           (103 )
integer*1 C1VALL                          ; preset C1VALL                           (104 )
integer*1 C1AND                           ; preset C1AND                            (105 )
integer*1 C1SIGNB                         ; preset C1SIGNB                          (106 )
integer*1 C1VALB                          ; preset C1VALB                           (107 )
integer*1 C2_ADD                          ; preset C2_ADD                           (108 )
integer*1 C2VARN                          ; preset C2VARN                           (109 )
integer*1 C2VARL                          ; preset C2VARL                           (110 )
integer*1 C2SIGNA                         ; preset C2SIGNA                          (111 )
integer*1 C2VALA                          ; preset C2VALA                           (112 )
integer*1 C2VALL                          ; preset C2VALL                           (113 )
integer*1 C2AND                           ; preset C2AND                            (114 )
integer*1 C2SIGNB                         ; preset C2SIGNB                          (115 )
integer*1 C2VALB                          ; preset C2VALB                           (116 )
integer*1 C3_ADD                          ; preset C3_ADD                           (117 )
integer*1 C3VARN                          ; preset C3VARN                           (118 )
integer*1 C3VARL                          ; preset C3VARL                           (119 )
integer*1 C3SIGNA                         ; preset C3SIGNA                          (120 )
integer*1 C3VALA                          ; preset C3VALA                           (121 )
integer*1 C3VALL                          ; preset C3VALL                           (122 )
integer*1 C3AND                           ; preset C3AND                            (123 )
integer*2 C3SIGNB                         ; preset C3SIGNB                          (124 )
integer*2 C3VALB                          ; preset C3VALB                           (125 )
integer*2 MATCH_B                         ; preset MATCH_B                          (126 )
integer*2 SAVE_REP                        ; preset SAVE_REP                         (127 )
integer*2 PAST_REP                        ; preset PAST_REP                         (128 )
integer*2 SAVE_SEA                        ; preset SAVE_SEA                         (129 )
integer*2 OPEN_SEA                        ; preset OPEN_SEA                         (130 )
integer*2 REP_TITL                        ; preset REP_TITL                         (131 )
integer*2 REP_SPEC                        ; preset REP_SPEC                         (132 )
integer*2 TABLEA_L                        ; preset TABLEA_L                         (133 )
integer*2 TABLEB_L                        ; preset TABLEB_L                         (134 )
integer*2 TABLEC_L                        ; preset TABLEC_L                         (135 )
integer*2 ID_00029                        ; preset ID_00029                         (136 )
integer*2 ID_00030                        ; preset ID_00030                         (137 )
integer*2 ID_00031                        ; preset ID_00031                         (138 )
integer*2 ID_00032                        ; preset ID_00032                         (139 )
integer*2 ID_00034                        ; preset ID_00034                         (140 )
integer*2 ID_00035                        ; preset ID_00035                         (141 )
integer*2 ID_00036                        ; preset ID_00036                         (142 )
integer*2 ID_00037                        ; preset ID_00037                         (143 )
integer*2 ID_00038                        ; preset ID_00038                         (144 )
integer*2 ID_00040                        ; preset ID_00040                         (145 )
integer*2 ID_00041                        ; preset ID_00041                         (146 )
integer*2 ID_00042                        ; preset ID_00042                         (147 )
integer*2 ID_00043                        ; preset ID_00043                         (148 )
integer*2 ID_00048                        ; preset ID_00048                         (149 )
integer*2 ID_00049                        ; preset ID_00049                         (150 )
integer*2 fyi_file                        ; preset fyi_file                         (151 )
integer*2 SHOWMORE                        ; preset SHOWMORE                         (152 )
integer*2 ID_00050                        ; preset ID_00050                         (153 )
integer*2 DELFILEX                        ; preset DELFILEX                         (154 )
integer*2 ID_00052                        ; preset ID_00052                         (155 )

|{ Prologue
|}

dialog "Search the Database for Variables and Frequencies"

|{ Controls
postype 1
edit     REP_TITLE                        ,  20,      139, 349, 0, 0
choice   ARECN                           ,  51,       60,  90
choice   ARECL                           ,  51,      152, 223
line     ID_00028                        ,   0, 408,   0, 604
button   A1_ADD                          ,  69,       41,  21, 0, "-"
choice   A1VARN                          ,  69,       64,  69
choice   A1VARL                          ,  69,      134, 148
choice   A1SIGNA                         ,  69,      285,  29
edit     A1VALA                          ,  69,      317,  55, 0, 0
choice   A1VALL                          ,  69,      375,  89
button   A1AND                           ,  69,      473,  28, 0, "And"
choice   A1SIGNB                         ,  69,      503,  29
edit     A1VALB                          ,  69,      535,  59, 0, 0
button   A2_ADD                          ,  87,       41,  21, 0, "Add"
choice   A2VARN                          ,  87,       64,  69
choice   A2VARL                          ,  87,      134, 148
choice   A2SIGNA                         ,  87,      285,  29
edit     A2VALA                          ,  87,      317,  55, 0, 0
choice   A2VALL                          ,  87,      375,  89
button   A2AND                           ,  88,      473,  28, 0, "And"
choice   A2SIGNB                         ,  88,      503,  29
edit     A2VALB                          ,  88,      535,  59, 0, 0
button   A3_ADD                          , 105,       41,  21, 0, "Add"
choice   A3VARN                          , 105,       64,  69
choice   A3VARL                          , 105,      134, 148
choice   A3SIGNA                         , 105,      285,  29
edit     A3VALA                          , 105,      317,  55, 0, 0
choice   A3VALL                          , 105,      375,  89
button   A3AND                           , 106,      473,  28, 0, "And"
choice   A3SIGNB                         , 106,      503,  29
edit     A3VALB                          , 106,      535,  59, 0, 0
button   A4_ADD                          , 123,       41,  21, 0, "Add"
choice   A4VARN                          , 123,       64,  69
choice   A4VARL                          , 123,      134, 148
choice   A4SIGNA                         , 123,      285,  29
edit     A4VALA                          , 123,      317,  55, 0, 0
choice   A4VALL                          , 123,      375,  89
button   A4AND                           , 124,      473,  28, 0, "And"
choice   A4SIGNB                         , 124,      503,  29
edit     A4VALB                          , 124,      535,  59, 0, 0
button   A5_ADD                          , 142,       41,  21, 0, "Add"
choice   A5VARN                          , 142,       64,  69
choice   A5VARL                          , 142,      134, 148
choice   A5SIGNA                         , 142,      285,  29
edit     A5VALA                          , 142,      317,  55, 0, 0
choice   A5VALL                          , 142,      375,  89
button   A5AND                           , 143,      473,  28, 0, "And"
choice   A5SIGNB                         , 143,      503,  29
edit     A5VALB                          , 143,      535,  59, 0, 0
choice   BRECN                           , 187,       60,  90
choice   BRECL                           , 187,      152, 223
button   B1_ADD                          , 206,       41,  21, 0, "Add"
choice   B1VARN                          , 205,       64,  69
choice   B1VARL                          , 205,      134, 148
choice   B1SIGNA                         , 205,      285,  29
edit     B1VALA                          , 205,      317,  55, 0, 0
choice   B1VALL                          , 205,      375,  89
button   B1AND                           , 205,      473,  28, 0, "And"
choice   B1SIGNB                         , 205,      503,  29
edit     B1VALB                          , 205,      535,  59, 0, 0
button   B2_ADD                          , 223,       41,  21, 0, "Add"
choice   B2VARN                          , 223,       64,  69
choice   B2VARL                          , 223,      134, 148
choice   B2SIGNA                         , 223,      285,  29
edit     B2VALA                          , 223,      317,  55, 0, 0
choice   B2VALL                          , 223,      375,  89
button   B2AND                           , 224,      473,  28, 0, "And"
choice   B2SIGNB                         , 224,      503,  29
edit     B2VALB                          , 224,      535,  59, 0, 0
button   B3_ADD                          , 241,       41,  21, 0, "Add"
choice   B3VARN                          , 241,       64,  69
choice   B3VARL                          , 241,      134, 148
choice   B3SIGNA                         , 241,      285,  29
edit     B3VALA                          , 241,      317,  55, 0, 0
choice   B3VALL                          , 241,      375,  89
button   B3AND                           , 242,      473,  28, 0, "And"
choice   B3SIGNB                         , 242,      503,  29
edit     B3VALB                          , 242,      535,  59, 0, 0
button   B4_ADD                          , 259,       41,  21, 0, "Add"
choice   B4VARN                          , 259,       64,  69
choice   B4VARL                          , 259,      134, 148
choice   B4SIGNA                         , 259,      285,  29
edit     B4VALA                          , 259,      317,  55, 0, 0
choice   B4VALL                          , 259,      375,  89
button   B4AND                           , 260,      473,  28, 0, "And"
choice   B4SIGNB                         , 260,      503,  29
edit     B4VALB                          , 260,      535,  59, 0, 0
button   B5_ADD                          , 278,       41,  21, 0, "Add"
choice   B5VARN                          , 278,       64,  69
choice   B5VARL                          , 278,      134, 148
choice   B5SIGNA                         , 278,      285,  29
edit     B5VALA                          , 278,      317,  55, 0, 0
choice   B5VALL                          , 278,      375,  89
button   B5AND                           , 279,      473,  28, 0, "And"
choice   B5SIGNB                         , 279,      503,  29
edit     B5VALB                          , 279,      535,  59, 0, 0
choice   CRECN                           , 321,       60,  90
choice   CRECL                           , 321,      152, 223
button   C1_ADD                          , 338,       41,  21, 0, "Add"
choice   C1VARN                          , 338,       64,  69
choice   C1VARL                          , 338,      134, 148
choice   C1SIGNA                         , 338,      285,  29
edit     C1VALA                          , 338,      317,  55, 0, 0
choice   C1VALL                          , 338,      375,  89
button   C1AND                           , 339,      473,  28, 0, "And"
choice   C1SIGNB                         , 339,      503,  29
edit     C1VALB                          , 339,      535,  59, 0, 0
button   C2_ADD                          , 357,       41,  21, 0, "Add"
choice   C2VARN                          , 357,       64,  69
choice   C2VARL                          , 357,      134, 148
choice   C2SIGNA                         , 357,      285,  29
edit     C2VALA                          , 357,      317,  55, 0, 0
choice   C2VALL                          , 357,      375,  89
button   C2AND                           , 357,      473,  28, 0, "And"
choice   C2SIGNB                         , 357,      503,  29
edit     C2VALB                          , 357,      535,  59, 0, 0
button   C3_ADD                          , 376,       41,  21, 0, "Add"
choice   C3VARN                          , 376,       64,  69
choice   C3VARL                          , 376,      134, 148
choice   C3SIGNA                         , 376,      285,  29
edit     C3VALA                          , 376,      317,  55, 0, 0
choice   C3VALL                          , 376,      375,  89
button   C3AND                           , 376,      473,  28, 0, "And"
choice   C3SIGNB                         , 376,      503,  29
edit     C3VALB                          , 376,      535,  59, 0, 0
button   MATCH_B                         ,   3,       41, 108, 1, "Show &Results "
button   SAVE_REP                        ,   3,      253,  63, 0, "Save Results"
button   PAST_REP                        ,   3,      318,  63, 0, "Past Results"
button   SAVE_SEA                        ,   3,      382,  63, 0, "Save Search"
button   OPEN_SEA                        ,   3,      446,  63, 0, "Load Search"
label    REP_TITL                        ,  24,        7, 124, "Title of your report: "
label    REP_SPEC                        ,  38,        6, 124, "Specify the criteria"
label    TABLEA_L                        ,  54,       15,  44, "Table A:"
label    TABLEB_L                        , 190,       15,  44, "Table B:"
label    TABLEC_L                        , 324,       15,  44, "Table C:"
label    ID_00029                        ,  71,       29,  10, "1."
label    ID_00030                        ,  89,       29,  10, "2."
label    ID_00031                        , 107,       29,  10, "3."
label    ID_00032                        , 125,       29,  10, "4."
label    ID_00034                        , 145,       29,  10, "5."
label    ID_00035                        , 208,       29,  10, "1."
label    ID_00036                        , 226,       29,  10, "2."
label    ID_00037                        , 244,       29,  10, "3."
label    ID_00038                        , 262,       29,  10, "4."
label    ID_00040                        , 280,       29,  10, "5."
label    ID_00041                        , 341,       29,  10, "1."
label    ID_00042                        , 359,       29,  10, "2."
label    ID_00043                        , 378,       29,  10, "3."
line     ID_00048                        , 170,   1,  14, 577
line     ID_00049                        , 306,   1,  14, 577
label    fyi_file                        , 397,      470, 132, "changes"
check    SHOWMORE                        ,  51,      480,  87, "More Options"
line     ID_00050                        ,  17,   1,   0, 603
button   IDCLOSE                         ,   3,      560,  40, 0, "Close"
button   DELFILEX                        ,   3,      515,  39, 0, "Delete"
label    ID_00052                        ,   5,       19,  16, "Go"
|}

initial
|{ Attribs
|< MATCH_B
. SET ITEM FONT MATCH_B,1,0,0, 0,""
|>
|< REP_TITL
. SET ITEM FONT REP_TITL,1,0,0, 0,""
|>
|< REP_SPEC
. SET ITEM FONT REP_SPEC,1,0,0, 0,""
|>
|< TABLEA_L
. SET ITEM FONT TABLEA_L,1,0,0, 0,""
|>
|< TABLEB_L
. SET ITEM FONT TABLEB_L,1,0,0, 0,""
|>
|< TABLEC_L
. SET ITEM FONT TABLEC_L,1,0,0, 0,""
|>
|< ID_00052
. SET ITEM FONT ID_00052,0,0,0, 0,"/#009900"
|>

|}
|{ Init
string  *  300   STR$1              | Large string for misc. use
string  *   45   REC_NAME           | The record name for appending to the drop down choices
string  *   11   TYPEDATE           | for checking date format in a MATCH
string  *   11   TYPETIME           | for checking time format in a MATCH
integer *    1   GOODCAT            | when checking to see if value is a valid catagorical value in MATCH
integer *    4   RT#                | record type #
integer *    1   PASS1VAR           | used for checking variables against schema
integer *    1   PASSALL#           | did the entire group of variablese pass the check.  1=Yes.
integer *    2   NVARS#             | # of Vars in a record
integer *    2   ARECNUM            | A More record type numbers in a specific format
integer *    2   BRECNUM            | B More record type numbers in a specific format
integer *    2   CRECNUM            | C More record type numbers in a specific format
integer *    2   TMP_RT#            | error checking, and writing to the PQL file
string  *   35   TMP_VAR            | error checking, and writing to the PQL file
string  *   35   TMP_SIA            | error checking, and writing to the PQL file
string  *   35   TMP_VALA           | error checking, and writing to the PQL file
string  *  100   VARL$              | For appending variable labels
string  *   45   VARN$              | For appending variable names
integer *    2   GUI_REC
integer *    2   GUI_VAR
integer *    2   GUI_VARL
integer *    2   GUI_SIGN
integer *    2   GUI_VAL
integer *    2   GUI_VALL
string  *  300   USER_FOL           | where the user folder is
string  *  300   USER_RNM           | If a user wants to save the program, he can rename it.
integer *    1   CHK_FILE           | check the folder, does it exist.
string  *  250   COMSTR             | To execute something from the command line create this string variable
integer *    1   RNM_OK             | Renaming the file was OK.  0=0k, -1 = NOT OK.
string  *   20   WHATFONT           | FONT
integer *    1   CHK_DIR            | Was the user directory create OK?
integer *    4   DUMB_N#            | Use anytime integer
integer *    2   RESVAR             | Captures users repsonses to prompts like NYC boxes.
integer *    2   RESVAR1            | Decided to have multiple RESVARS because they can occur so many times in a row
integer *    2   RESVAR2            | Decided to have multiple RESVARS because they can occur so many times in a row
string  *   25   FILE_NAM           | User can choose a file name.
string  *  200   array USER_FLS (1) | Names of the user files
integer *    2   FILES#             | How many files are there?
string  *   45   V_NAME             | Varialble name for VALLIST
integer *    2   POSIT#1            | Which numberic position in the value label list is it
string  *  600   ALINE$             | Each line during a read file.
string  *  300   FILELOC$           | Where to load the file from
integer *    2   AT_DOT             | During import it needs to find the :
integer *    1   ERR#_REC           | Record Flag: If the schema has changed and no longer matches the import, set IMP_ERR# flag
integer *    1   ERR#_VAR           | Variable Flag: If the schema has changed and no longer matches the import, set IMP_ERR# flag
integer *    1   ERR#_BTH           | Overall Flag: If the schema has changed and no longer matches the import, set IMP_ERR# flag
string  *   50   GUI_STR            | Name of the GUI control as a string
integer *    2   GUI_XXX            | Number of GUI Item to set or append
integer *    2   GUI_XXXL           | Number of GUI Label (note that the label is always 1 after the Item.
string  *  250   LIST_VAL           | The value to set GUI control to.
integer *    2   NUM_REC#           | The actually number of records.  When loading a file, I have to cycle throug the drop down choices getting the text for each one to see if it matches.
string  *   35   ARECTXT            | A record type name
string  *   35   BRECTXT            | B record type name
string  *   35   CRECTXT            | C record type name
STRING  *  250   USER_CRIT_1        | Constructing the 1st criteria in the PQL program
STRING  *  250   USER_CRIT_2        | Constructing the 2nd criteria in the PQL program
integer *    1   FILES#1            | How many files of a certain type are in the user's folder.
integer *    2   NUM_VAR#           | How many varialbes in the record type.  It could be Rec A or B or C.
string  *    5   TMP_AND            | Is it "And" or "Or"
string  *  250   TMP_FILELOC        | What is the name of the temporary program file
set WHATFONT   ('Courier New')
set item font ARECN   ,1,0,0,3,WHATFONT
set item font ARECL   ,1,0,0,3,WHATFONT
set item font BRECN   ,1,0,0,3,WHATFONT
set item font BRECL   ,1,0,0,3,WHATFONT
set item font CRECN   ,1,0,0,3,WHATFONT
set item font CRECL   ,1,0,0,3,WHATFONT
set item font TABLEA_L,1,0,0,3,WHATFONT
set item font TABLEB_L,1,0,0,3,WHATFONT
set item font TABLEC_L,1,0,0,3,WHATFONT
set item font REP_TITL,1,0,0,3,WHATFONT
set item font REP_SPEC,1,0,0,3,WHATFONT
set item FYI_FILE, 'Designed by Greg Neils at the D.C.C.'
compute USER_FOL = dsn('PREFIX') + 'USERS\'
compute USER_FOL = USER_FOL + sglobal('USERA') +'\'
|
c SIGN
. do repeat X= '=' '<' '<='  'NE' '>=' '>'
.   append item A1SIGNA,X
.   append item A2SIGNA,X
.   append item A3SIGNA,X
.   append item A4SIGNA,X
.   append item A5SIGNA,X
.   append item B1SIGNA,X
.   append item B2SIGNA,X
.   append item B3SIGNA,X
.   append item B4SIGNA,X
.   append item B5SIGNA,X
.   append item C1SIGNA,X
.   append item C2SIGNA,X
.   append item C3SIGNA,X
c
.   append item A1SIGNB,X
.   append item A2SIGNB,X
.   append item A3SIGNB,X
.   append item A4SIGNB,X
.   append item A5SIGNB,X
.   append item B1SIGNB,X
.   append item B2SIGNB,X
.   append item B3SIGNB,X
.   append item B4SIGNB,X
.   append item B5SIGNB,X
.   append item C1SIGNB,X
.   append item C2SIGNB,X
.   append item C3SIGNB,X
. end repeat
|
. compute NUM_REC# = 0
. for DUMB_N1 =1,nrecs(0)   |rec numbers for Selection Criteria.  NUM_REC# is used again in the OPEN FILE.
.   compute REC_NAME = pack(recname(DUMB_N1))
.   ifnot (len(REC_NAME) GT 0) next for
.   compute NUM_REC# = NUM_REC# + 1
.   append item ARECN,REC_NAME
.   append item ARECL,pack(recdoc(DUMB_N1,1))
.   append item BRECN,REC_NAME
.   append item BRECL,pack(recdoc(DUMB_N1,1))
.   append item CRECN,REC_NAME
.   append item CRECL,pack(recdoc(DUMB_N1,1))
. end for
. execute subprocedure CLEARALL
. execute subprocedure AVARLIST
. execute subprocedure BVARLIST
. execute subprocedure CVARLIST
. show item A1VARN
. show item A1VARL
. show item A1SIGNA
. show item A1VALA
. show item A1VALL
. set  item A1_ADD, '-'
. execute subprocedure GET_COMPLEX
. hide item save_rep
. hide item past_rep
|
|}
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
|}

ifthen (m_id eq ARECN )
|< ARECN
. select item ARECL,   getpos (ARECN)
. execute subprocedure AREMOVAL
. execute subprocedure AVARLIST
|>
next message
endif

ifthen (m_id eq ARECL )
|< ARECL
. select item ARECN,getpos (ARECL)
. execute subprocedure AREMOVAL
. execute subprocedure AVARLIST
|>
next message
endif

ifthen (m_id eq A1_ADD )
|< A1_ADD
. ifthen (gettxt(A1_ADD) EQ 'Add')
.   show item A1VARN
.   show item A1VARL
.   show item A1SIGNA
.   show item A1VALA
.   show item A1VALL
.   set  item A1_ADD, '-'
. else
.   hide item A1VARN
.   hide item A1VARL
.   hide item A1SIGNA
.   hide item A1VALA
.   hide item A1VALL
.   set  item A1_ADD, 'Add'
. endif

|>
next message
endif

ifthen (m_id eq A1VARN )
|< A1VARN
. select item A1VARL, getpos (A1VARN)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A1VALA
. GUI_VAR   = A1VARN
. GUI_VALL  = A1VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A1VARL )
|< A1VARL
. select item A1VARN, getpos (A1VARL)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A1VALA
. GUI_VAR   = A1VARN
. GUI_VALL  = A1VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A1VALA )
|< A1VALA
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A1VARN
. GUI_VAL  = A1VALA
. GUI_VALL = A1VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq A1VALL )
|< A1VALL
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A1VARN
. GUI_VAL  = A1VALA
. GUI_VALL = A1VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq A1AND )
|< A1AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq A2_ADD )
|< A2_ADD
. ifthen (gettxt(A2_ADD) EQ 'Add')
.   show item A2VARN
.   show item A2VARL
.   show item A2SIGNA
.   show item A2VALA
.   show item A2VALL
.   set  item A2_ADD, '-'
. else
.   hide item A2VARN
.   hide item A2VARL
.   hide item A2SIGNA
.   hide item A2VALA
.   hide item A2VALL
.   set  item A2_ADD, 'Add'
. endif
execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq A2VARN )
|< A2VARN
. select item A2VARL, getpos (A2VARN)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A2VALA
. GUI_VAR   = A2VARN
. GUI_VALL  = A2VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A2VARL )
|< A2VARL
. select item A2VARN, getpos (A2VARL)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A2VALA
. GUI_VAR   = A2VARN
. GUI_VALL  = A2VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A2VALA )
|< A2VALA
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A2VARN
. GUI_VAL  = A2VALA
. GUI_VALL = A2VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq A2VALL )
|< A2VALL
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A2VARN
. GUI_VAL  = A2VALA
. GUI_VALL = A2VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq A2AND )
|< A2AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq A3_ADD )
|< A3_ADD
. ifthen (gettxt(A3_ADD) EQ 'Add')
.   show item A3VARN
.   show item A3VARL
.   show item A3SIGNA
.   show item A3VALA
.   show item A3VALL
.   set  item A3_ADD, '-'
. else
.   hide item A3VARN
.   hide item A3VARL
.   hide item A3SIGNA
.   hide item A3VALA
.   hide item A3VALL
.   set  item A3_ADD, 'Add'
. endif
execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq A3VARN )
|< A3VARN
. select item A3VARL, getpos (A3VARN)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A3VALA
. GUI_VAR   = A3VARN
. GUI_VALL  = A3VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A3VARL )
|< A3VARL
. select item A3VARN, getpos (A3VARL)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A3VALA
. GUI_VAR   = A3VARN
. GUI_VALL  = A3VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A3VALA )
|< A3VALA
. GUI_VAR  = A3VARN
. RT# = recnum(gettxt(ARECN))
. GUI_VAL  = A3VALA
. GUI_VALL = A3VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq A3VALL )
|< A3VALL
. GUI_VAR  = A3VARN
. RT# = recnum(gettxt(ARECN))
. GUI_VAL  = A3VALA
. GUI_VALL = A3VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq A3AND )
|< A3AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq A4_ADD )
|< A4_ADD
. ifthen (gettxt(A4_ADD) EQ 'Add')
.   show item A4VARN
.   show item A4VARL
.   show item A4SIGNA
.   show item A4VALA
.   show item A4VALL
.   set  item A4_ADD, '-'

. else
.   hide item A4VARN
.   hide item A4VARL
.   hide item A4SIGNA
.   hide item A4VALA
.   hide item A4VALL
.   set  item A4_ADD, 'Add'
. endif
execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq A4VARN )
|< A4VARN
. select item A4VARL, getpos (A4VARN)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A4VALA
. GUI_VAR   = A4VARN
. GUI_VALL  = A4VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A4VARL )
|< A4VARL
. select item A4VARN, getpos (A4VARL)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A4VALA
. GUI_VAR   = A4VARN
. GUI_VALL  = A4VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A4VALA )
|< A4VALA
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A4VARN
. GUI_VAL  = A4VALA
. GUI_VALL = A4VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq A4VALL )
|< A4VALL
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A4VARN
. GUI_VAL  = A4VALA
. GUI_VALL = A4VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq A4AND )
|< A4AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq A5_ADD )
|< A5_ADD
. ifthen (gettxt(A5_ADD) EQ 'Add')
.   show item A5VARN
.   show item A5VARL
.   show item A5SIGNA
.   show item A5VALA
.   show item A5VALL
.   set  item A5_ADD, '-'
. else
.   hide item A5VARN
.   hide item A5VARL
.   hide item A5SIGNA
.   hide item A5VALA
.   hide item A5VALL
.   set  item A5_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq A5VARN )
|< A5VARN
. select item A5VARL, getpos (A5VARN)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A5VALA
. GUI_VAR   = A5VARN
. GUI_VALL  = A5VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A5VARL )
|< A5VARL
. select item A5VARN, getpos (A5VARL)
. RT# = recnum(gettxt(ARECN))
. GUI_VAL   = A5VALA
. GUI_VAR   = A5VARN
. GUI_VALL  = A5VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq A5VALA )
|< A5VALA
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A5VARN
. GUI_VAL  = A5VALA
. GUI_VALL = A5VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq A5VALL )
|< A5VALL
. RT# = recnum(gettxt(ARECN))
. GUI_VAR  = A5VARN
. GUI_VAL  = A5VALA
. GUI_VALL = A5VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq A5AND )
|< A5AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq BRECN )
|< BRECN
. select item BRECL,   getpos (BRECN)
. execute subprocedure BREMOVAL
. execute subprocedure BVARLIST
|>
next message
endif

ifthen (m_id eq BRECL )
|< BRECL
. select item BRECL,   getpos (BRECN)
. execute subprocedure BREMOVAL
. execute subprocedure BVARLIST
|>
next message
endif

ifthen (m_id eq B1_ADD )
|< B1_ADD
. ifthen (gettxt(B1_ADD) EQ 'Add')
.   show item B1VARN
.   show item B1VARL
.   show item B1SIGNA
.   show item B1VALA
.   show item B1VALL
.   set  item B1_ADD, '-'
. else
.   hide item B1VARN
.   hide item B1VARL
.   hide item B1SIGNA
.   hide item B1VALA
.   hide item B1VALL
.   set  item B1_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq B1VARN )
|< B1VARN
. select item B1VARL, getpos (B1VARN)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B1VALA
. GUI_VAR   = B1VARN
. GUI_VALL  = B1VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B1VARL )
|< B1VARL
. select item B1VARN, getpos (B1VARL)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B1VALA
. GUI_VAR   = B1VARN
. GUI_VALL  = B1VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B1VALA )
|< B1VALA
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B1VARN
. GUI_VAL  = B1VALA
. GUI_VALL = B1VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq B1VALL )
|< B1VALL
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B1VARN
. GUI_VAL  = B1VALA
. GUI_VALL = B1VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq B1AND )
|< B1AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq B2_ADD )
|< B2_ADD
. ifthen (gettxt(B2_ADD) EQ 'Add')
.   show item B2VARN
.   show item B2VARL
.   show item B2SIGNA
.   show item B2VALA
.   show item B2VALL
.   set  item B2_ADD, '-'
. else
.   hide item B2VARN
.   hide item B2VARL
.   hide item B2SIGNA
.   hide item B2VALA
.   hide item B2VALL
.   set  item B2_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq B2VARN )
|< B2VARN
. select item B2VARL, getpos (B2VARN)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B2VALA
. GUI_VAR   = B2VARN
. GUI_VALL  = B2VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B2VARL )
|< B2VARL
. select item B2VARN, getpos (B2VARL)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B2VALA
. GUI_VAR   = B2VARN
. GUI_VALL  = B2VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B2VALA )
|< B2VALA
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B2VARN
. GUI_VAL  = B2VALA
. GUI_VALL = B2VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq B2VALL )
|< B2VALL
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B2VARN
. GUI_VAL  = B2VALA
. GUI_VALL = B2VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq B2AND )
|< B2AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq B3_ADD )
|< B3_ADD
. ifthen (gettxt(B3_ADD) EQ 'Add')
.   show item B3VARN
.   show item B3VARL
.   show item B3SIGNA
.   show item B3VALA
.   show item B3VALL
.   set  item B3_ADD, '-'
. else
.   hide item B3VARN
.   hide item B3VARL
.   hide item B3SIGNA
.   hide item B3VALA
.   hide item B3VALL
.   set  item B3_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq B3VARN )
|< B3VARN
. select item B3VARL, getpos (B3VARN)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B3VALA
. GUI_VAR   = B3VARN
. GUI_VALL  = B3VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B3VARL )
|< B3VARL
. select item B3VARN, getpos (B3VARL)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B3VALA
. GUI_VAR   = B3VARN
. GUI_VALL  = B3VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B3VALA )
|< B3VALA
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B3VARN
. GUI_VAL  = B3VALA
. GUI_VALL = B3VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq B3VALL )
|< B3VALL
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B3VARN
. GUI_VAL  = B3VALA
. GUI_VALL = B3VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq B3AND )
|< B3AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq B4_ADD )
|< B4_ADD
. ifthen (gettxt(B4_ADD) EQ 'Add')
.   show item B4VARN
.   show item B4VARL
.   show item B4SIGNA
.   show item B4VALA
.   show item B4VALL
.   set  item B4_ADD, '-'
. else
.   hide item B4VARN
.   hide item B4VARL
.   hide item B4SIGNA
.   hide item B4VALA
.   hide item B4VALL
.   set  item B4_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq B4VARN )
|< B4VARN
. select item B4VARL, getpos (B4VARN)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B4VALA
. GUI_VAR   = B4VARN
. GUI_VALL  = B4VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B4VARL )
|< B4VARL
. select item B4VARN, getpos (B4VARL)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B4VALA
. GUI_VAR   = B4VARN
. GUI_VALL  = B4VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B4VALA )
|< B4VALA
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B4VARN
. GUI_VAL  = B4VALA
. GUI_VALL = B4VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq B4VALL )
|< B4VALL
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B4VARN
. GUI_VAL  = B4VALA
. GUI_VALL = B4VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq B4AND )
|< B4AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq B5_ADD )
|< B5_ADD
. ifthen (gettxt(B5_ADD) EQ 'Add')
.   show item B5VARN
.   show item B5VARL
.   show item B5SIGNA
.   show item B5VALA
.   show item B5VALL
.   set  item B5_ADD, '-'
. else
.   hide item B5VARN
.   hide item B5VARL
.   hide item B5SIGNA
.   hide item B5VALA
.   hide item B5VALL
.   set  item B5_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq B5VARN )
|< B5VARN
. select item B5VARL, getpos (B5VARN)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B5VALA
. GUI_VAR   = B5VARN
. GUI_VALL  = B5VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B5VARL )
|< B5VARL
. select item B5VARN, getpos (B5VARL)
. RT# = recnum(gettxt(BRECN))
. GUI_VAL   = B5VALA
. GUI_VAR   = B5VARN
. GUI_VALL  = B5VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq B5VALA )
|< B5VALA
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B5VARN
. GUI_VAL  = B5VALA
. GUI_VALL = B5VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq B5VALL )
|< B5VALL
. RT# = recnum(gettxt(BRECN))
. GUI_VAR  = B5VARN
. GUI_VAL  = B5VALA
. GUI_VALL = B5VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq B5AND )
|< B5AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq CRECN )
|< CRECN
. select item CRECL,   getpos (CRECN)
. execute subprocedure CREMOVAL
. execute subprocedure CVARLIST
|>
next message
endif

ifthen (m_id eq CRECL )
|< CRECL
. select item CRECL,   getpos (CRECN)
. execute subprocedure CREMOVAL
. execute subprocedure CVARLIST
|>
next message
endif

ifthen (m_id eq C1_ADD )
|< C1_ADD
. ifthen (gettxt(C1_ADD) EQ 'Add')
.   show item C1VARN
.   show item C1VARL
.   show item C1SIGNA
.   show item C1VALA
.   show item C1VALL
.   set  item C1_ADD, '-'
. else
.   hide item C1VARN
.   hide item C1VARL
.   hide item C1SIGNA
.   hide item C1VALA
.   hide item C1VALL
.   set  item C1_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq C1VARN )
|< C1VARN
. select item C1VARL, getpos (C1VARN)
. RT# = recnum(gettxt(CRECN))
. GUI_VAL   = C1VALA
. GUI_VAR   = C1VARN
. GUI_VALL  = C1VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq C1VARL )
|< C1VARL
. select item C1VARN, getpos (C1VARL)
. RT# = recnum(gettxt(CRECN))
. GUI_VAL   = C1VALA
. GUI_VAR   = C1VARN
. GUI_VALL  = C1VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq C1VALA )
|< C1VALA
. RT# = recnum(gettxt(CRECN))
. GUI_VAR  = C1VARN
. GUI_VAL  = C1VALA
. GUI_VALL = C1VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq C1VALL )
|< C1VALL
. RT# = recnum(gettxt(CRECN))
. GUI_VAR  = C1VARN
. GUI_VAL  = C1VALA
. GUI_VALL = C1VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq C1AND )
|< C1AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq C2_ADD )
|< C2_ADD
. ifthen (gettxt(C2_ADD) EQ 'Add')
.   show item C2VARN
.   show item C2VARL
.   show item C2SIGNA
.   show item C2VALA
.   show item C2VALL
.   set  item C2_ADD, '-'
. else
.   hide item C2VARN
.   hide item C2VARL
.   hide item C2SIGNA
.   hide item C2VALA
.   hide item C2VALL
.   set  item C2_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq C2VARN )
|< C2VARN
. select item C2VARL, getpos (C2VARN)
. RT# = recnum(gettxt(CRECN))
. GUI_VAL   = C2VALA
. GUI_VAR   = C2VARN
. GUI_VALL  = C2VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq C2VARL )
|< C2VARL
. select item C2VARN, getpos (C2VARL)
. RT# = recnum(gettxt(CRECN))
. GUI_VAL   = C2VALA
. GUI_VAR   = C2VARN
. GUI_VALL  = C2VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq C2VALA )
|< C2VALA
. RT# = recnum(gettxt(CRECN))
. GUI_VAR  = C2VARN
. GUI_VAL  = C2VALA
. GUI_VALL = C2VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq C2VALL )
|< C2VALL
. RT# = recnum(gettxt(CRECN))
. GUI_VAR  = C2VARN
. GUI_VAL  = C2VALA
. GUI_VALL = C2VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq C2AND )
|< C2AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq C3_ADD )
|< C3_ADD
. ifthen (gettxt(C3_ADD) EQ 'Add')
.   show item C3VARN
.   show item C3VARL
.   show item C3SIGNA
.   show item C3VALA
.   show item C3VALL
.   set  item C3_ADD, '-'
. else
.   hide item C3VARN
.   hide item C3VARL
.   hide item C3SIGNA
.   hide item C3VALA
.   hide item C3VALL
.   set  item C3_ADD, 'Add'
. endif
. execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq C3VARN )
|< C3VARN
. select item C3VARL, getpos (C3VARN)
. RT# = recnum(gettxt(CRECN))
. GUI_VAL   = C3VALA
. GUI_VAR   = C3VARN
. GUI_VALL  = C3VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq C3VARL )
|< C3VARL
. select item C3VARN, getpos (C3VARL)
. RT# = recnum(gettxt(CRECN))
. GUI_VAL   = C3VALA
. GUI_VAR   = C3VARN
. GUI_VALL  = C3VALL
. execute subprocedure LISTVAL
|>
next message
endif

ifthen (m_id eq C3VALA )
|< C3VALA
. RT# = recnum(gettxt(CRECN))
. GUI_VAR  = C3VARN
. GUI_VAL  = C3VALA
. GUI_VALL = C3VALL
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq C3VALL )
|< C3VALL
. RT# = recnum(gettxt(CRECN))
. GUI_VAR  = C3VARN
. GUI_VAL  = C3VALA
. GUI_VALL = C3VALL
. execute subprocedure SETVALX
|>
next message
endif

ifthen (m_id eq C3AND )
|< C3AND
execute subprocedure CHANGE_AND_OR
|>
next message
endif

ifthen (m_id eq MATCH_B )
|< MATCH_B
. compute PASSALL# = 1
. execute subprocedure CHK_ALL_VARS
. if (PASSALL# = 0) NEXT MESSAGE
c
. execute subprocedure BRAINS
c
execute dbms ['include file "' +dsn('seach_pql') +'"']
c
DUMB_N# = help('file: "'+dsn('seach_html')+'"')

TMP_FILELOC = 'AutoSave '+ datec(today(0),'yyyy-mm-dd') + timec(now(0),'___hh-mm__')

if (exists(gettxt(REP_TITLE)) eq 1) TMP_FILELOC = TMP_FILELOC + gettxt(REP_TITLE)

TMP_FILELOC = TMP_FILELOC + '.pql'
write TMP_FILELOC
DUMB_N# = cpyfile(dsn('seach_pql'),TMP_FILELOC )  | 0 eq successul copy. -1= fail, -2 Problem target file.  -3 errors in copy.


c . display yesnobox "Do you want to see the code?" response RESVAR
c . ifthen (RESVAR eq 1)
c .   compute COMSTR = 'EDITFILE "' + dsn('seach_html') +'"/clear'; EXECUTE DBMS COMSTR  | The HTML output table
c .   compute COMSTR = 'EDITFILE "' + dsn('seach_pql') +'"/clear'; EXECUTE DBMS COMSTR  | The PQL program that is created
c . endif
|>
next message
endif

ifthen (m_id eq SAVE_REP )
|< SAVE_REP
c only allow 20 files to be saved.  We don't want too much junk on the server
. compute FILES# = filecnt(USER_FOL+'RepResults*.html')
. ifthen (FILES# GE 20)
.   display yncbox "Max number of saved files is 20.  You must delete one first.  Delete one?" RESPONSE resvar
.   ifthen (RESVAR eq 1) |OK
.     redefine array 'USER_FLS' (FILES#)
.     for DUMB_N1= 1,FILES#
.       compute USER_FLS(DUMB_N1) = filen(USER_FOL+'RepResults*.html',DUMB_N1)
.       compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),12,len(USER_FLS(DUMB_N1)))
.     end for
.     display popup list USER_FLS,FILES#
                    anchor   SAVE_REP, POSTYPE 1
                    response RESVAR
.     ifthen (RESVAR eq 0)
.       display infobox "Sorry, can not save at this time"
.       NEXT MESSAGE
.     endif
.     display yncbox "DELETE THIS FILE?: " + USER_FLS(RESVAR) response RESVAR
.     ifthen (RESVAR eq 1)
.       compute USER_RNM = USER_FOL + 'RepResults_'+ USER_FLS(RESVAR)
.       compute CHK_FILE = delfile (USER_RNM)
.     else
.       display infobox "Sorry, can not save at this time.(1)"
.       NEXT MESSAGE
.     endif
.   else
.     display infobox "Sorry, can not save at this time.(2)"
.     NEXT MESSAGE
.   endif
. endif
c see if they want to use an existing file
. ifthen (FILES# gt 0)
.   compute FILES# = filecnt(USER_FOL+'RepResults*.html')
.   compute FILES#1 = FILES# + 1
.   redefine array 'USER_FLS' (FILES#1)
.   for DUMB_N1= 1,FILES#
.     compute USER_FLS(DUMB_N1) = filen(USER_FOL+'RepResults*.html',DUMB_N1)
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),12,len(USER_FLS(DUMB_N1)))
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),1,len(USER_FLS(DUMB_N1))-5)
.   end for
.   compute USER_FLS(FILES#+1) = "Other"
.   display popup list USER_FLS,FILES#+1
                  anchor   SAVE_REP, POSTYPE 1
                  response RESVAR1

.   if (RESVAR1 LE 0) NEXT MESSAGE

.   ifthen (RESVAR1 le FILES#)
.     compute USER_RNM = USER_FOL + filen(USER_FOL+'RepResults*.html',RESVAR1)
.   elseif (RESVAR1 eq FILES#+1) | Other
.     display textbox "Please type a name for your file" response RESVAR2, FILE_NAM
.     if (RESVAR2 eq -1) NEXT MESSAGE
.     compute FILE_NAM = replace (FILE_NAM,'.','_',3,1,0)  | remove any periods (.) that a user might have added with "_"
.     compute USER_RNM = USER_FOL + 'RepResults_'+ FILE_NAM + '.html'
.   endif
. else
.   display textbox "Please type a name for your file" response RESVAR2, FILE_NAM
.   if (RESVAR2 eq -1) NEXT MESSAGE
.   compute FILE_NAM = replace (FILE_NAM,'.','_',3,1,0)  | remove any periods (.) that a user might have added with "_"
.   compute USER_RNM = USER_FOL + 'RepResults_'+ FILE_NAM + '.html'
. endif

c save it
. compute CHK_FILE = fileis(USER_RNM)
. ifthen (CHK_FILE EQ 1) | exists already.  Ask first.
.   display yncbox "File already exists.  Do you want to replace it?" response RESVAR
.   ifthen (RESVAR eq 1) |OK
.     compute RNM_OK = delfile (USER_RNM) |first delete the old file
.     compute RNM_OK = rnmfile(dsn('seach_html'),USER_RNM)  | 0 eq successul rename. -1= fail
.     if (RNM_OK ne 0) display infobox "Sorry I can not replace the file at this time.(3)"
.   endif
. else | file doesnt already exists- OK to create
.   compute RNM_OK = rnmfile(dsn('seach_html'),USER_RNM) | 0 eq successul rename. -1= fail
.   if (RNM_OK ne 0) display infobox "Sorry I can not save them file at this time.(4)"
. endif
|>
next message
endif

ifthen (m_id eq PAST_REP )
|< PAST_REP
. compute FILES# = filecnt(USER_FOL+'RepResults*.html')
. ifthen (FILES# > 0)
.   redefine array 'USER_FLS' (FILES#)
.   for DUMB_N1= 1,FILES#
.     compute USER_FLS(DUMB_N1) = filen(USER_FOL+'RepResults*.html',DUMB_N1)
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),12,len(USER_FLS(DUMB_N1)))
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),1,len(USER_FLS(DUMB_N1))-5)
.   end for
.   display popup list USER_FLS,FILES#
                  anchor   PAST_REP, POSTYPE 1
                  response RESVAR
.   if (RESVAR eq 0) next message

.   compute FILELOC$ = USER_FOL+ filen(USER_FOL+'RepResults*.html',RESVAR)
.   compute DUMB_N#  = help('file: "'+FILELOC$+'"')
. endif
|>
next message
endif

ifthen (m_id eq SAVE_SEA )
|< SAVE_SEA
C FIRST DO THE CHECKS AND CREATE THE FILE.  PERHAPS THEY UPDATED IT FROM THE LAST RUN
. compute PASSALL# = 1
. execute subprocedure CHK_ALL_VARS
. if (PASSALL# = 0) NEXT MESSAGE
. execute subprocedure BRAINS |Creates the file
C
c only allow 20 files to be saved.  We don't want too much junk on the server
. compute FILES# = filecnt(USER_FOL + 'search*.pql')
. ifthen (FILES# GE 20)
.   display yncbox "Max number of saved files is 20.  You must delete one first.  Delete one?" RESPONSE resvar
.   ifthen (RESVAR eq 1) |OK
.     redefine array 'USER_FLS' (FILES#)
.     for DUMB_N1= 1,FILES#
.       compute USER_FLS(DUMB_N1) = filen(USER_FOL+'search*.pql',DUMB_N1)
.       compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),8,len(USER_FLS(DUMB_N1)))
.     end for
.     display popup list USER_FLS,FILES#
                    anchor   SAVE_SEA, POSTYPE 1
                    response RESVAR
.     ifthen (RESVAR eq 0)
.       display infobox "Sorry, can not save at this time"
.       NEXT MESSAGE
.     endif
.     display yncbox "DELETE THIS FILE?: " + USER_FLS(RESVAR) response RESVAR
.     ifthen (RESVAR eq 1)
.       compute USER_RNM = USER_FOL + 'search_'+ USER_FLS(RESVAR)
.       compute CHK_FILE = delfile (USER_RNM)
.     else
.       display infobox "Sorry, can not save at this time"
.       NEXT MESSAGE
.     endif
.   else
.     display infobox "Sorry, can not save at this time"
.     NEXT MESSAGE
.   endif
. endif
c see if they want to use an existing file
. ifthen (FILES# gt 0)
.   compute FILES# = filecnt(USER_FOL+'search*.pql')
.   compute FILES#1 = FILES# + 1
.   redefine array 'USER_FLS' (FILES#1)
.   for DUMB_N1= 1,FILES#
.     compute USER_FLS(DUMB_N1) = filen(USER_FOL+'search*.pql',DUMB_N1)
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),8,len(USER_FLS(DUMB_N1)))
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),1,len(USER_FLS(DUMB_N1))-4)
.   end for
.   compute USER_FLS(FILES#+1) = "Other"
.   display popup list USER_FLS,FILES#+1
                  anchor   SAVE_SEA, POSTYPE 1
                  response RESVAR1

.   if (RESVAR1 LE 0) NEXT MESSAGE

.   ifthen (RESVAR1 le FILES#)
.     compute USER_RNM = USER_FOL + filen(USER_FOL+'search*.pql',RESVAR1)
.   elseif (RESVAR1 eq FILES#+1) | Other
.     display textbox "Please type a name for your file" response RESVAR2, FILE_NAM
.     if (RESVAR2 eq -1) NEXT MESSAGE
.     compute FILE_NAM = replace (FILE_NAM,'.','_',3,1,0)  | remove any periods (.) that a user might have added with "_"
.     compute USER_RNM = USER_FOL + 'search_'+ FILE_NAM + '.pql'
.   endif
. else
.   display textbox "Please type a name for your file" response RESVAR2, FILE_NAM
.   if (RESVAR2 eq -1) NEXT MESSAGE
.   compute FILE_NAM = replace (FILE_NAM,'.','_',3,1,0)  | remove any periods (.) that a user might have added with "_"
.   compute USER_RNM = USER_FOL + 'search_'+ FILE_NAM + '.pql'
. endif

c save it
. compute CHK_FILE = fileis(USER_RNM)
. ifthen (CHK_FILE EQ 1) | exists already.  Ask first.
.   display yncbox "File already exists.  Do you want to replace it?" response RESVAR
.   ifthen (RESVAR eq 1) |OK
.     compute RNM_OK = delfile (USER_RNM) |first delete the old file
.     compute RNM_OK = rnmfile(dsn('seach_pql'),USER_RNM)  | 0 eq successul rename. -1= fail
.     if (RNM_OK ne 0) display infobox "Sorry I can not replace the file at this time"
.   endif
. else | file doesnt already exists- OK to create
.   compute RNM_OK = rnmfile(dsn('seach_pql'),USER_RNM) | 0 eq successul rename. -1= fail
.   if (RNM_OK ne 0) display infobox "Sorry I can not save them file at this time"
. endif
|>
next message
endif

ifthen (m_id eq OPEN_SEA )
|< OPEN_SEA
. compute FILES# = filecnt(USER_FOL+'search*.pql')
. ifthen (FILES# > 0)
.   redefine array 'USER_FLS' (FILES#)
.   for DUMB_N1= 1,FILES#
.     compute USER_FLS(DUMB_N1) = filen(USER_FOL+'search*.pql',DUMB_N1)
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),8,len(USER_FLS(DUMB_N1)))
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),1,len(USER_FLS(DUMB_N1))-4)
.   end for
.   display popup list USER_FLS,FILES#
                  anchor   OPEN_SEA, POSTYPE 1
                  response RESVAR
.   if (RESVAR eq 0) next message


.   execute subprocedure CLEARALL

.   compute FILELOC$ = USER_FOL+ filen(USER_FOL+'search*.pql',RESVAR)
.   set item FYI_FILE, 'Created ' + datec(filetime(FILELOC$,4),'mm/dd/yy')
.   compute ERR#_BTH = 0
.   open (temp) dsnvar = FILELOC$ / read / iostat = MYIOSTAT / lrecl=600
.   while (MYIOSTAT = 0)
.     read (temp,end=done) ALINE$ (A600)
.     compute ALINE$ = pack(ALINE$)
.     compute ERR#_REC = 0
.     compute ERR#_VAR = 0
.     ifthen (srst(ALINE$,'| import') eq 1 )
c       import
.       compute AT_DOT   = abs(srst(ALINE$,':'))
.       compute GUI_STR = substr(ALINE$, 10 , (AT_DOT - 10))
.       compute GUI_XXX  = numbr(varget(GUI_STR))
.       compute GUI_XXXL = GUI_XXX + 1 | The label must always be 1 after the value or it will not work.
.       ifthen (exists(GUI_XXX) eq 0)
.         compute ERR#_BTH = 1
.       endif
.       if(ERR#_BTH =1) EXIT IF  | MAJOR PROBLEM~! There was a problem finding the GUI Control
.       compute LIST_VAL = substr(ALINE$, (AT_DOT + 2) , len(ALINE$)) | (35 - (AT_DOT+1)))
c       record types, rec labels, variables, varialbe labels
.       ifthen (GUI_STR = 'REP_TITLE')
.         set item GUI_XXX, LIST_VAL
.       endif
.       ifthen ((GUI_STR = 'ARECN') or
                (GUI_STR = 'BRECN') or
                (GUI_STR = 'CRECN'))
.         show item GUI_XXX
.         show item GUI_XXXL
.         compute ERR#_REC = 1 |  Say it is an error and prove otherwise
.         for DUMB_N1 = 1, NUM_REC# | ACTUAL number of records TYPES in database
.           select item GUI_XXX, DUMB_N1
.           select item GUI_XXXL,DUMB_N1
.           ifthen (gettxt(GUI_XXX) eq LIST_VAL)
.             if (GUI_STR = 'ARECN') execute subprocedure AVARLIST;
.             if (GUI_STR = 'BRECN') execute subprocedure BVARLIST
.             if (GUI_STR = 'CRECN') execute subprocedure CVARLIST
.             compute ERR#_REC = 0 |  Found One. No Err
.             EXIT FOR
.           endif
.         end for
.       endif

c       variables and variable labels
.       ifthen (srst(GUI_STR, 'VARN') lt 0) | Variable Name
.         show item GUI_XXX
.         show item GUI_XXXL
.         set item  GUI_XXX-1, '-'
.         if (substr(GUI_STR,1,1) = 'A') compute NUM_VAR# = nvarsc( recnum(gettxt(ARECN)))
.         if (substr(GUI_STR,1,1) = 'B') compute NUM_VAR# = nvarsc( recnum(gettxt(BRECN)))
.         if (substr(GUI_STR,1,1) = 'C') compute NUM_VAR# = nvarsc( recnum(gettxt(CRECN)))
.         compute ERR#_VAR = 1 |  Say it is an error and prove otherwise
.         for DUMB_N1 = 1, NUM_VAR# | ACTUAL number of records TYPES in database
.           select item GUI_XXX, DUMB_N1
.           select item GUI_XXXL, DUMB_N1
.           ifthen (pack(gettxt(GUI_XXX)) eq pack(LIST_VAL))
.             compute ERR#_VAR = 0 |  Say it is an error and prove otherwise
.             EXIT FOR
.           endif
.         end for
.         if (substr(GUI_STR,1,1) = 'A') RT# = recnum(gettxt(ARECN))
.         if (substr(GUI_STR,1,1) = 'B') RT# = recnum(gettxt(BRECN))
.         if (substr(GUI_STR,1,1) = 'C') RT# = recnum(gettxt(CRECN))
.         compute GUI_VAR = GUI_XXX
.         compute GUI_VAL = GUI_XXX + 3
.         compute GUI_VALL = GUI_XXX + 4
.         execute subprocedure LISTVAL   | GUI_VAR, GUI_VAL  and GUI_VALL  are passed.
.       endif
c       equation sign
.       ifthen (srst(GUI_STR,'SIGN') lt 0)  | Sign
.         show item   GUI_XXX
.         for DUMB_N1 = 1, NUM_REC# | ACTUAL number of records TYPES in database
.           select item GUI_XXX, DUMB_N1
.           ifthen (gettxt(GUI_XXX) eq LIST_VAL)
.             EXIT FOR
.           endif
.         end for
.       endif

c       values and value labels for the first variable
.       ifthen (srst(GUI_STR,'VALA') lt 0)
.         show item GUI_XXX
.         show item GUI_XXXL
.         set item  GUI_XXX, LIST_VAL
.         if (substr(GUI_STR,1,1) = 'A') RT# = recnum(gettxt(ARECN))
.         if (substr(GUI_STR,1,1) = 'B') RT# = recnum(gettxt(BRECN))
.         if (substr(GUI_STR,1,1) = 'C') RT# = recnum(gettxt(CRECN))
.         compute GUI_VAR = GUI_XXX - 3
.         compute GUI_VAL = GUI_XXX
.         compute GUI_VALL = GUI_XXX + 1
.         execute subprocedure SETVALL  | GUI_VAR GUI_VAL GUI_VALL are passed in
.       endif
.       if((ERR#_REC = 1) or (ERR#_VAR = 1)) compute ERR#_BTH = 1

c       values for the SECOND variable
.       ifthen (srst(GUI_STR,'VALB') lt 0)  | Sign
.         show item GUI_XXX
.         set item  GUI_XXX,LIST_VAL
.       endif

c       values for the AND/OR button
.       ifthen (srst(GUI_STR,'AND') lt 0)  | Sign
.         show item GUI_XXX
.         set item  GUI_XXX,LIST_VAL
.       endif
.       ifthen (GUI_STR = 'SHOWMORE' )  | More Options
.         ifthen (LIST_VAL = '0')
.           uncheck item SHOWMORE
.         else
.           check item  SHOWMORE
.         endif
.       endif

.     endif  | End of Import line.
.   end while
.   done:
.   close (temp)
.   if (ERR#_BTH = 1) display infobox "The database has changed since this was created.  Please review and correct your search."
. endif
|>
next message
endif

ifthen (m_id eq SHOWMORE )
|< SHOWMORE
execute subprocedure GET_COMPLEX
|>
next message
endif

ifthen (m_id eq DELFILEX )
|< DELFILEX
. compute FILES#1 = filecnt(USER_FOL+'RepResults*.html')
. compute FILES#2 = filecnt(USER_FOL+'Search*.pql')
. compute FILES#3 = FILES#1 + FILES#2
. ifthen (FILES#3 > 0)
.   redefine array 'USER_FLS' (FILES#3)
.   for DUMB_N1= 1,FILES#1
.     compute USER_FLS(DUMB_N1) = filen(USER_FOL+'RepResults*.html',DUMB_N1)
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),12,len(USER_FLS(DUMB_N1)))
.     compute USER_FLS(DUMB_N1) = substr(USER_FLS(DUMB_N1),1,len(USER_FLS(DUMB_N1))-5)
.   end for
.   for DUMB_N1= 1,FILES#2
.     compute DUMB_N2 = DUMB_N1 + FILES#1
.     compute USER_FLS(DUMB_N2) = filen(USER_FOL+'Search*.pql',DUMB_N1) | N1 AND N2 ARE BOTH CORRECT
.     compute USER_FLS(DUMB_N2) = substr(USER_FLS(DUMB_N2),8,len(USER_FLS(DUMB_N2))) |N2 IS CORRECT
.     compute USER_FLS(DUMB_N2) = substr(USER_FLS(DUMB_N2),1,len(USER_FLS(DUMB_N2))-4) |N2 IS CORRECT
.   end for
.   display popup list USER_FLS,FILES#3
                  anchor   DELFILEX, POSTYPE 1
                  response RESVARA
.   if (RESVARA eq 0) next message

.   display yncbox "Delete " + USER_FLS(RESVARA) response RESVARB
.   ifthen (RESVARB eq 1)
.     ifthen (RESVARA lt FILES#1) | Must be RepResults
.       compute USER_RNM = USER_FOL + 'RepResults_'+ USER_FLS(RESVARA) + '.html'
.       compute CHK_FILE = delfile (USER_RNM)
.     else
.       compute USER_RNM = USER_FOL + 'Search_'+ USER_FLS(RESVARA) + '.pql'
.       compute CHK_FILE = delfile (USER_RNM)
.     endif
.   endif
. endif
|>
next message
endif

if (m_id eq 0) exit message

end message


end dialog
|{ Exit
|}
|{ Footer
subprocedure AVARLIST    |displays all of the variables for rec A variables
c This appends the variliables to the choice boxes based on the selected record
. compute RT#     =  recnum(gettxt(ARECN))
. for NVARS# = 1,nvarsc(RT#)                 |NVARS#=numbered variables
.   compute VARN$  = varnamec(RT#,NVARS#)
.   compute VARL$ = pack(varlabsc(RT#,varnamec(RT#,NVARS#)))
.   append item A1VARN, VARN$
.   append item A2VARN, VARN$
.   append item A3VARN, VARN$
.   append item A4VARN, VARN$
.   append item A5VARN, VARN$
.   append item A1VARL, VARL$
.   append item A2VARL, VARL$
.   append item A3VARL, VARL$
.   append item A4VARL, VARL$
.   append item A5VARL, VARL$
. end for
. GUI_VAR   = A1VARN
. GUI_VAL   = A1VALA
. GUI_VALL  = A1VALL
. execute subprocedure VALLIST
end subprocedure
|
|
subprocedure BVARLIST    |displays all of the variables for rec A variables
c This appends the variliables to the choice boxes based on the selected record
. compute RT#     =  recnum(gettxt(BRECN))
. execute subprocedure BREMOVAL
. for NVARS# = 1,nvarsc(RT#)                 |NVARS#=numbered variables
.   compute VARN$ = varnamec(RT#,NVARS#)
.   compute VARL$ = pack(varlabsc(RT#,varnamec(RT#,NVARS#)))
.   append item B1VARN, VARN$
.   append item B2VARN, VARN$
.   append item B3VARN, VARN$
.   append item B4VARN, VARN$
.   append item B5VARN, VARN$
.   append item B1VARL, VARL$
.   append item B2VARL, VARL$
.   append item B3VARL, VARL$
.   append item B4VARL, VARL$
.   append item B5VARL, VARL$
. end for
. GUI_VAR   = B1VARN
. GUI_VAL   = B1VALA
. GUI_VALL  = B1VALL
. execute subprocedure VALLIST
end subprocedure
|
|
subprocedure CVARLIST    |displays all of the variables for rec A variables
c This appends the variliables to the choice boxes based on the selected record
. compute RT#     =  recnum(gettxt(CRECN))
. execute subprocedure CREMOVAL
. for NVARS# = 1,nvarsc(RT#)                 |NVARS#=numbered variables
.   compute VARN$ = varnamec(RT#,NVARS#)
.   compute VARL$ = pack(varlabsc(RT#,varnamec(RT#,NVARS#)))
.   append item C1VARN, VARN$
.   append item C2VARN, VARN$
.   append item C3VARN, VARN$
.   append item C1VARL, VARL$
.   append item C2VARL, VARL$
.   append item C3VARL, VARL$
. end for
. GUI_VAR   = C1VARN
. GUI_VAL   = C1VALA
. GUI_VALL  = C1VALL
. execute subprocedure VALLIST
end subprocedure
|
|
subprocedure AREMOVAL
.  remove all A1VARN
.  remove all A1VARL
.  remove all A1VALA
.  remove all A1VALL
.  remove all A2VARN
.  remove all A2VALL
.  remove all A2VALA
.  remove all A2VARL
.  remove all A3VARN
.  remove all A3VALL
.  remove all A3VALA
.  remove all A3VARL
.  remove all A4VARN
.  remove all A4VALL
.  remove all A4VALA
.  remove all A4VARL
.  remove all A5VARN
.  remove all A5VALL
.  remove all A5VALA
.  remove all A5VARL
.  remove all A1VALB
.  remove all A2VALB
.  remove all A3VALB
.  remove all A4VALB
.  remove all A5VALB
end subprocedure
|
|
subprocedure BREMOVAL
.  remove all B1VARN
.  remove all B1VARL
.  remove all B1VALA
.  remove all B1VALL
.  remove all B2VARN
.  remove all B2VALL
.  remove all B2VALA
.  remove all B2VARL
.  remove all B3VARN
.  remove all B3VALL
.  remove all B3VALA
.  remove all B3VARL
.  remove all B4VARN
.  remove all B4VALL
.  remove all B4VALA
.  remove all B4VARL
.  remove all B5VARN
.  remove all B5VALL
.  remove all B5VALA
.  remove all B5VARL
.  remove all B1VALB
.  remove all B2VALB
.  remove all B3VALB
.  remove all B4VALB
.  remove all B5VALB
end subprocedure
|
|
subprocedure CREMOVAL
.  remove all C1VARN
.  remove all C1VARL
.  remove all C1VALA
.  remove all C1VALL
.  remove all C2VARN
.  remove all C2VALL
.  remove all C2VALA
.  remove all C2VARL
.  remove all C3VARN
.  remove all C3VALL
.  remove all C3VALA
.  remove all C3VARL
.  remove all C1VALB
.  remove all C2VALB
.  remove all C3VALB
end subprocedure
|
|
subprocedure CLEARALL
. remove all REP_TITLE
. execute subprocedure AREMOVAL
. execute subprocedure BREMOVAL
. execute subprocedure CREMOVAL
. do repeat XSHOW    = $A1_ADD$ $A2_ADD$ $A3_ADD$ $A4_ADD$ $A5_ADD$ $B1_ADD$ $B2_ADD$ $B3_ADD$ $B4_ADD$ $B5_ADD$  $C1_ADD$ $C2_ADD$ $C3_ADD$  /
            XVARX    = A1VARN   A2VARN   A3VARN   A4VARN   A5VARN   B1VARN   B2VARN   B3VARN   B4VARN   B5VARN    C1VARN   C2VARN   C3VARN    /
            XVARLX   = A1VARL   A2VARL   A3VARL   A4VARL   A5VARL   B1VARL   B2VARL   B3VARL   B4VARL   B5VARL    C1VARL   C2VARL   C3VARL    /
            XSIGNA   = A1SIGNA  A2SIGNA  A3SIGNA  A4SIGNA  A5SIGNA  B1SIGNA  B2SIGNA  B3SIGNA  B4SIGNA  B5SIGNA   C1SIGNA  C2SIGNA  C3SIGNA   /
            XVALA    = A1VALA   A2VALA   A3VALA   A4VALA   A5VALA   B1VALA   B2VALA   B3VALA   B4VALA   B5VALA    C1VALA   C2VALA   C3VALA    /
            XVALAL   = A1VALL   A2VALL   A3VALL   A4VALL   A5VALL   B1VALL   B2VALL   B3VALL   B4VALL   B5VALL    C1VALL   C2VALL   C3VALL    /
            XAND     = A1AND    A2AND    A3AND    A4AND    A5AND    B1AND    B2AND    B3AND    B4AND    B5AND     C1AND    C2AND    C3AND     /
            XSIGNB   = A1SIGNB  A2SIGNB  A3SIGNB  A4SIGNB  A5SIGNB  B1SIGNB  B2SIGNB  B3SIGNB  B4SIGNB  B5SIGNB   C1SIGNB  C2SIGNB  C3SIGNB   /
            XVALB    = A1VALB   A2VALB   A3VALB   A4VALB   A5VALB   B1VALB   B2VALB   B3VALB   B4VALB   B5VALB    C1VALB   C2VALB   C3VALB
.   set item XSHOW 'Add'
.   hide item XVARX
.   hide item XVARLX
.   hide item XSIGNA
.   hide item XVALA
.   hide item XVALAL
.   set item XAND, 'And'
.   hide item XAND
.   hide item XSIGNB
.   hide item XVALB
. end repeat
end subprocedure
|
|
|
subprocedure BRAINS
| brains here
compute ARECTXT = gettxt(ARECN)
compute BRECTXT = gettxt(BRECN)
compute CRECTXT = gettxt(CRECN)
compute ARECNUM = recnum(gettxt(ARECN))
compute BRECNUM = recnum(gettxt(BRECN))
compute CRECNUM = recnum(gettxt(CRECN))
open (seach_html) / write / lrecl = 600
. compute STR$1 ='<' + CHAR(33) + 'DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">'
. write (seach_html) STR$1
. write (seach_html) '<html>'
. write (seach_html) '<head>'
. write (seach_html) '  <title>'
. STR$1 = gettxt(REP_TITLE)
. ifthen  (exists(STR$1) eq 1)
.   write (seach_html)
. else
.   write (seach_html) '    Your Search Request for'
. endif
. write (seach_html) '  </title>'
. write (seach_html) '</head>'
. write (seach_html) ''
. write (seach_html) '<body>'
. write (seach_html) ''
. write (seach_html) '<table width="100%" border=0 bgcolor="#FFFFB0">'
. write (seach_html) '  <tr>'
. write (seach_html) '    <td><strong>'
. if (exists(STR$1) eq 1) write (seach_html) STR$1
. write (seach_html) '</strong></td>'
. write (seach_html) '    <tr><td><p><big>Generated on ' [datec(today(0),'mm/dd/yy')]  ' at ' [timec(now(0),'hh:mm')] 'by ' [sglobal('USERA')]  ' and the D.C.C.</big></p></td></tr>'
. write (seach_html) '  </tr>'
. write (seach_html) '<tr><td>The following criteria was used</tr></td>' /
C CONSTRUCT the 2nd variable criteria first.
. do repeat XSHOW    = $A1_ADD$  $A2_ADD$  $A3_ADD$  $A4_ADD$  $A5_ADD$  $B1_ADD$  $B2_ADD$  $B3_ADD$  $B4_ADD$  $B5_ADD$  $C1_ADD$  $C2_ADD$  $C3_ADD$ /
            XRECX    = ARECTXT   ARECTXT   ARECTXT   ARECTXT   ARECTXT   BRECTXT   BRECTXT   BRECTXT   BRECTXT   BRECTXT   CRECTXT   CRECTXT   CRECTXT  /
            XVARN    = A1VARN    A2VARN    A3VARN    A4VARN    A5VARN    B1VARN    B2VARN    B3VARN    B4VARN    B5VARN    C1VARN    C2VARN    C3VARN   /
            XVARL    = A1VARL    A2VARL    A3VARL    A4VARL    A5VARL    B1VARL    B2VARL    B3VARL    B4VARL    B5VARL    C1VARL    C2VARL    C3VARL   /
            XSIGNA   = A1SIGNA   A2SIGNA   A3SIGNA   A4SIGNA   A5SIGNA   B1SIGNA   B2SIGNA   B3SIGNA   B4SIGNA   B5SIGNA   C1SIGNA   C2SIGNA   C3SIGNA  /
            XVALA    = A1VALA    A2VALA    A3VALA    A4VALA    A5VALA    B1VALA    B2VALA    B3VALA    B4VALA    B5VALA    C1VALA    C2VALA    C3VALA   /
            XVALL    = A1VALL    A2VALL    A3VALL    A4VALL    A5VALL    B1VALL    B2VALL    B3VALL    B4VALL    B5VALL    C1VALL    C2VALL    C3VALL  /
            XAND     = A1AND     A2AND     A3AND     A4AND     A5AND     B1AND     B2AND     B3AND     B4AND     B5AND     C1AND     C2AND     C3AND    /
            XSIGNB   = A1SIGNB   A2SIGNB   A3SIGNB   A4SIGNB   A5SIGNB   B1SIGNB   B2SIGNB   B3SIGNB   B4SIGNB   B5SIGNB   C1SIGNB   C2SIGNB   C3SIGNB  /
            XVALB    = A1VALB    A2VALB    A3VALB    A4VALB    A5VALB    B1VALB    B2VALB    B3VALB    B4VALB    B5VALB    C1VALB    C2VALB    C3VALB
.   ifthen (gettxt(XSHOW) EQ '-')
.     compute STR$1 = ''
.     compute STR$1 = '  <tr><td><strong>Table:</strong> '+ XRECX +' <strong>Variable:</strong> ' + gettxt(XVARN) +' "' +gettxt(XVARL) + '" '
.     compute STR$1 = STR$1 + gettxt(XSIGNA) + ' '
.     ifthen (gettxt(XVALA) eq '')
.       compute STR$1 = STR$1 + 'Missing '
.     else
.       compute STR$1 = STR$1 + gettxt(XVALA) + ' ' + gettxt(XVALL)
.     endif
.     ifthen ( (gettxt(XVALB) ne '') AND (getichk(SHOWMORE) EQ 1) )
.       compute STR$1 = STR$1 + gettxt(XAND) + ' ' + gettxt(XSIGNB) + ' ' + gettxt(XVALB)
.     endif
.     compute STR$1 = STR$1 + '</tr></td>'
.     write (seach_html) STR$1
.   endif
. end repeat
. write (seach_html) '</table>' /
. write (seach_html) '<hr>'
. write (seach_html) '<table  border ="1" cellspacing ="2" cellpadding="2">' /
. write (seach_html) '  <tr>'
. write (seach_html) '  <td>KEYS</td>'
. do repeat XSHOW    = $A1_ADD$  $A2_ADD$  $A3_ADD$  $A4_ADD$  $A5_ADD$  $B1_ADD$  $B2_ADD$  $B3_ADD$  $B4_ADD$  $B5_ADD$  $C1_ADD$  $C2_ADD$  $C3_ADD$ /
            XVARN    = A1VARN    A2VARN    A3VARN    A4VARN    A5VARN    B1VARN    B2VARN    B3VARN    B4VARN    B5VARN    C1VARN    C2VARN    C3VARN   /
            XSIGNA   = A1SIGNA   A2SIGNA   A3SIGNA   A4SIGNA   A5SIGNA   B1SIGNA   B2SIGNA   B3SIGNA   B4SIGNA   B5SIGNA   C1SIGNA   C2SIGNA   C3SIGNA  /
            XVALA    = A1VALA    A2VALA    A3VALA    A4VALA    A5VALA    B1VALA    B2VALA    B3VALA    B4VALA    B5VALA    C1VALA    C2VALA    C3VALA   /
            XAND     = A1AND     A2AND     A3AND     A4AND     A5AND     B1AND     B2AND     B3AND     B4AND     B5AND     C1AND     C2AND     C3AND    /
            XSIGNB   = A1SIGNB   A2SIGNB   A3SIGNB   A4SIGNB   A5SIGNB   B1SIGNB   B2SIGNB   B3SIGNB   B4SIGNB   B5SIGNB   C1SIGNB   C2SIGNB   C3SIGNB  /
            XVALB    = A1VALB    A2VALB    A3VALB    A4VALB    A5VALB    B1VALB    B2VALB    B3VALB    B4VALB    B5VALB    C1VALB    C2VALB    C3VALB
.   ifthen (gettxt(XSHOW) EQ '-')
.     compute STR$1 = '<td>' + gettxt(XVARN) + ' ' + gettxt(XSIGNA) + ' ' + gettxt(XVALA)
.     ifthen ( (gettxt(XVALB) ne '') AND (getichk(SHOWMORE) EQ 1) )
.       compute STR$1 = STR$1 + '<br>' + gettxt(XAND) + ' ' + gettxt(XSIGNB) + ' ' + gettxt(XVALB)
.     endif
.     compute STR$1 = STR$1 + '</td>'
.     write (seach_html) STR$1
.   endif
. end repeat
. write (seach_html) '  </tr>'/
close (seach_html)
open (seach_pql) / write  / lrecl=600
. write (seach_pql) 'retrieval progress |crwarn'
. write (seach_pql) 'integer * 4 CNT_REC#' | Total number of matches
. write (seach_pql) 'integer * 4 CNTMISS#' | Number of system missing that were found.  This affects the results.
. write (seach_pql) 'integer * 4 CNTCASE#' | Number of Cases that matched criteria.  Not everyone will be interested in this.
. write (seach_pql) 'real    * 8 INC_RECX' | Did everything match criteria
. write (seach_pql) 'real    * 8 INCCASEX' | Case matches criteria.  Only increase count 1 time per case.
. write (seach_pql) 'string * 250 KEYSTR$1 KEYSTR$2 KEYSTR$3'
. write (seach_pql) '| Version: 1.0'
. write (seach_pql) '| Created: ' [datec(today(0),'mm/dd/yy')]
. write (seach_pql) '| Code for importing below'
. STR$1 = gettxt(REP_TITLE)
. write (seach_pql) '| import REP_TITLE:' 35t STR$1
. write (seach_pql) '| import SHOWMORE:' 35t [getichk(SHOWMORE)] | 0)No Check.  1)Checked
. write (seach_pql) '| import ARECN:' 35t ARECTXT
. write (seach_pql) '| import BRECN:' 35t BRECTXT
. write (seach_pql) '| import CRECN:' 35t CRECTXT
. do repeat XSHOW      = $A1_ADD$  $A2_ADD$  $A3_ADD$  $A4_ADD$  $A5_ADD$  $B1_ADD$  $B2_ADD$  $B3_ADD$  $B4_ADD$  $B5_ADD$  $C1_ADD$  $C2_ADD$  $C3_ADD$ /
            XVARXA     = A1VARN    A2VARN    A3VARN    A4VARN    A5VARN    B1VARN    B2VARN    B3VARN    B4VARN    B5VARN    C1VARN    C2VARN    C3VARN   /
            XSIGNA     = A1SIGNA   A2SIGNA   A3SIGNA   A4SIGNA   A5SIGNA   B1SIGNA   B2SIGNA   B3SIGNA   B4SIGNA   B5SIGNA   C1SIGNA   C2SIGNA   C3SIGNA  /
            XVALA      = A1VALA    A2VALA    A3VALA    A4VALA    A5VALA    B1VALA    B2VALA    B3VALA    B4VALA    B5VALA    C1VALA    C2VALA    C3VALA   /
            XAND       = A1AND     A2AND     A3AND     A4AND     A5AND     B1AND     B2AND     B3AND     B4AND     B5AND     C1AND     C2AND     C3AND    /
            XSIGNB     = A1SIGNB   A2SIGNB   A3SIGNB   A4SIGNB   A5SIGNB   B1SIGNB   B2SIGNB   B3SIGNB   B4SIGNB   B5SIGNB   C1SIGNB   C2SIGNB   C3SIGNB  /
            XVALB      = A1VALB    A2VALB    A3VALB    A4VALB    A5VALB    B1VALB    B2VALB    B3VALB    B4VALB    B5VALB    C1VALB    C2VALB    C3VALB
.   ifthen (gettxt(XSHOW) EQ '-')
.     write (seach_pql) '| import XVARXA:' 35t [gettxt(XVARXA)]
.     write (seach_pql) '| import XSIGNA:' 35t [gettxt(XSIGNA)]
.     write (seach_pql) '| import XVALA: ' 35t [gettxt(XVALA)]
.     ifthen (getichk(SHOWMORE) eq 1)
.       write (seach_pql) '| import XAND:  ' 35t [gettxt(XAND)]
.       write (seach_pql) '| import XSIGNB:' 35t [gettxt(XSIGNB)]
.       write (seach_pql) '| import XVALB: ' 35t [gettxt(XVALB)]
.     endif
.   endif
. end repeat
. write (seach_pql) 'set CNT_REC# (0)'
. write (seach_pql) 'set CNTMISS# (0)'
. write (seach_pql) 'set CNTCASE# (0)'
. write (seach_pql) 'open (seach_html) / append / lrecl=600'
cif eq 1,0<G_CASED>
. write (seach_pql) 'process cases'
cif end
. write (seach_pql) '. autoset'
. write (seach_pql) '. compute INCCASEX = 0'
. write (seach_pql) '. compute KEYSTR$1 = "" '   | zero out at the case level and in each record
. write (seach_pql) '. compute KEYSTR$2 = "" '   | zero out at the case level and in each record
. write (seach_pql) '. compute KEYSTR$3 = "" '   | zero out at the case level and in each record
. write (seach_pql) '. process rec ' ARECTXT
. write (seach_pql) '.   compute KEYSTR$1 = ""'
. write (seach_pql) '.   compute INC_RECX = 1'
. ifthen (gettxt(A1_ADD) EQ '-')
.   TMP_RT#  = ARECNUM
.   TMP_VAR  = gettxt(A1VARN)
.   TMP_SIA  = gettxt(A1SIGNA)
.   TMP_VALA = gettxt(A1VALA)
.   TMP_AND  = gettxt(A1AND)
.   TMP_SIB  = gettxt(A1SIGNB)
.   TMP_VALB = gettxt(A1VALB)
.   execute subprocedure GET_VAR_INFO
. endif
. ifthen (gettxt(A2_ADD) EQ '-')
.   TMP_RT#  = ARECNUM
.   TMP_VAR  = gettxt(A2VARN)
.   TMP_SIA  = gettxt(A2SIGNA)
.   TMP_VALA = gettxt(A2VALA)
.   TMP_AND  = gettxt(A2AND)
.   TMP_SIB  = gettxt(A2SIGNB)
.   TMP_VALB = gettxt(A2VALB)
.   execute subprocedure GET_VAR_INFO
. endif
. ifthen ((gettxt(A3_ADD) EQ '-'))
.   TMP_RT#  = ARECNUM
.   TMP_VAR  = gettxt(A3VARN)
.   TMP_SIA  = gettxt(A3SIGNA)
.   TMP_VALA = gettxt(A3VALA)
.   TMP_AND  = gettxt(A3AND)
.   TMP_SIB  = gettxt(A3SIGNB)
.   TMP_VALB = gettxt(A3VALB)
.   execute subprocedure GET_VAR_INFO
. endif
. ifthen ((gettxt(A4_ADD) EQ '-'))
.   TMP_RT#  = ARECNUM
.   TMP_VAR  = gettxt(A4VARN)
.   TMP_SIA  = gettxt(A4SIGNA)
.   TMP_VALA = gettxt(A4VALA)
.   TMP_AND  = gettxt(A4AND)
.   TMP_SIB  = gettxt(A4SIGNB)
.   TMP_VALB = gettxt(A4VALB)
.   execute subprocedure GET_VAR_INFO
. endif
. ifthen ((gettxt(A5_ADD) EQ '-'))
.   TMP_RT#  = ARECNUM
.   TMP_VAR  = gettxt(A5VARN)
.   TMP_SIA  = gettxt(A5SIGNA)
.   TMP_VALA = gettxt(A5VALA)
.   TMP_AND  = gettxt(A5AND)
.   TMP_SIB  = gettxt(A5SIGNB)
.   TMP_VALB = gettxt(A5VALB)
.   execute subprocedure GET_VAR_INFO
. endif
. write (seach_pql) '|'
. write (seach_pql) '.   ifthen (INC_RECX = 1)'
. ifthen (nkeys(ARECNUM) gt 0)
.   write (seach_pql) '.     compute KEYSTR$1 = "' [pack(recname(ARECNUM))] ':"'
.   for n=2,nkeys(ARECNUM)+1
.     write (seach_pql) '.     compute KEYSTR$1 = KEYSTR$1 + "' [pack(keyname(ARECNUM,n))] '" + varget("' [pack(keyname(ARECNUM,n))] '")' '+"<br>"'
.   end for
. endif
|  CONTINUE TO RECORD TYPE B
. ifthen ((gettxt(B1_ADD) EQ '-') or
          (gettxt(B2_ADD) EQ '-') or
          (gettxt(B3_ADD) EQ '-') or
          (gettxt(B4_ADD) EQ '-') or
          (gettxt(B5_ADD) EQ '-'))
.   execute subprocedure INCLUDEB  | INCLUDE THE B RECORD TYPE
. else
|   RECORD TYPE B IS NOT INCLUDE.
.   execute subprocedure SHOW_THE_DATA
. endif
|
. write (seach_pql) '.   endif'
. write (seach_pql) '. end rec'
. write (seach_pql) '. if (INCCASEX = 1) compute CNTCASE# = CNTCASE# +1'
cif eq 1,0<G_CASED>
. write (seach_pql) 'end cases'
cif end
. write (seach_pql) 'write (seach_html) "<tr><td colspan = 5>Total records that matched all criteria: " CNT_REC# "</td></tr>"'
. write (seach_pql) 'write (seach_html) "<tr><td colspan = 5>Total cases that matched criteria atleast once: " CNTCASE# "</td></tr>"'
. write (seach_pql) 'write (seach_html) "<tr><td colspan = 5>Variables with missing data(0): " CNTMISS# "</td></tr>"'
. write (seach_pql) 'write (seach_html) "</table>"'
. write (seach_pql) 'write (seach_html) "</body>"'
. write (seach_pql) 'write (seach_html) "</html>"'
. write (seach_pql) 'close (seach_html)'
. write (seach_pql) 'end retrieval'
|
close (seach_pql)
c
end subprocedure BRAINS
|
|
subprocedure LISTVAL
c RT# GUI_VAR, GUI_VAL  and GUI_VALL  are passed in.
. remove all GUI_VAL
. remove all GUI_VALL
. execute subprocedure VALLIST
end subprocedure LISTVAL
|
|
subprocedure VALLIST   |appends all value labels to variable
c RT# GUI_VAR  and GUI_VALL  are passed in
. compute V_NAME = gettxt(GUI_VAR)
. if then (nvallab(RT#,V_NAME) GT 0)   |1st try value labels and it will only show things with value labels (it will ignore ranges)
.   for K = 1, nvallab(RT#,V_NAME)              |K=numbered value labels
.     append item GUI_VALL, vallabsn(RT#,V_NAME,K)
.   end for
.   append item GUI_VALL, ''
. else if (nvalid(RT#, V_NAME) GT 0)
.   for N = 1, nvalid(RT#, V_NAME)
.     if (vtype(RT#, V_NAME) = 2)   append item GUI_VALL, svval ( RT#,V_NAME, n)
.     if (vtype(RT#, V_NAME) = 5)   append item GUI_VALL, nvval ( RT#,V_NAME, n)
.   end for
. else if ((exists(nmin(RT#, V_NAME))) and (exists(nmax(RT#, V_NAME))))
.   if then (nmax(RT#, V_NAME) - nmin(RT#, V_NAME) lt 400)
.     for n=nmin(RT#, V_NAME), nmax(RT#, V_NAME)
.       append item GUI_VALL, N
.     end for
.   end if
. end if
. execute subprocedure SETVALX
end subprocedure VALLIST
|
|
|
subprocedure SETVALL   |SET VALUE LABELS
| RT# GUI_VAR GUI_VAL GUI_VALL are passed in
. compute POSIT#1 = vallabsp (RT#,gettxt(GUI_VAR),gettxt(GUI_VAL))
. if then (gettxt(GUI_VAL) = '')  |blank
.   select item GUI_VALL, nvallab(RT#, gettxt(GUI_VAR)) + 1
. else if (POSIT#1 ne 0)
.   select item GUI_VALL, POSIT#1
. else
.   POSIT#1 = nvallab(RT#,gettxt(GUI_VAR)) + 1
.   select item GUI_VALL, POSIT#1
. end if
end subprocedure |SETVALL
|
|
subprocedure SETVALX |SET ACTUAL VALUE
| RT# GUI_VAR GUI_VAL GUI_VALL are passed in
. for K = 1, nvallab(RT#,pack(gettxt(GUI_VAR)))              |K=numbered value labels
.   if (pack(vallabsn(RT#,gettxt(GUI_VAR),K)) = pack(gettxt(GUI_VALL))) compute POSIT#1 = K
. end for
. if then (nvallab(RT#,gettxt(GUI_VAR)) gt 0)
.   set item GUI_VAL, vallabsv (RT#,gettxt(GUI_VAR),POSIT#1)
. else
.   set item GUI_VAL, gettxt(GUI_VALL)
. end if
. if (gettxt(GUI_VALL) eq '') set item GUI_VAL,''
end subprocedure |SETVALX
|
|
subprocedure CHK_VALS   | RT#, SIGN$, TXTVAR1, EDITVAL  ALL MUST BE PASSED TO THIS PROCEDURE
c write TMP_RT# TMP_VAR TMP_SIA TMP_VALA
. compute PASS1VAR = 1  |lets assume everything is all right.
. if then ((TMP_SIA eq '=') and (TMP_VALA eq '') )
.    |PASS1VAR stays the same
. else if ((TMP_VALA eq '') and (TMP_SIA ne '='))
.    display infobox "Opps, you need to use =  for blanks: " + pack(varlabsc(TMP_RT#,TMP_VAR))
.    compute PASS1VAR=0
. else if (vtype(TMP_RT#, TMP_VAR) eq 1)  | string
.    if then (numbr(substr(vformat(TMP_RT#,TMP_VAR),1,len(vformat(TMP_RT#,TMP_VAR)))) gt len(TMP_VALA))
.       display infobox 'Boggie, That is too long for '+  pack(varlabsc(TMP_RT#,TMP_VAR))
.       compute PASS1VAR=0
.    end if
. else if (vtype(TMP_RT#,TMP_VAR) eq 2)  | catagorical
.    compute GOODCAT=0
.    for N=1,nvalid(TMP_RT#,TMP_VAR)  |must cycle thru and get values instead of use "catint"
.       if then ((TMP_SIA eq '<')  and (svval (TMP_RT#,TMP_VAR, N ) <  TMP_VALA ))   compute GOODCAT=1      |VALID VALUE
.       else if ((TMP_SIA eq '<=') and (svval (TMP_RT#,TMP_VAR, N ) <= TMP_VALA ))   compute GOODCAT=1      |VALID VALUE
.       else if ((TMP_SIA eq '=')  and (svval (TMP_RT#,TMP_VAR, N ) =  TMP_VALA ))   compute GOODCAT=1      |VALID VALUE
.       else if ((TMP_SIA eq '>=') and (svval (TMP_RT#,TMP_VAR, N ) >= TMP_VALA ))   compute GOODCAT=1      |VALID VALUE
.       else if ((TMP_SIA eq '>')  and (svval (TMP_RT#,TMP_VAR, N ) >  TMP_VALA ))   compute GOODCAT=1      |VALID VALUE
.       else if ((TMP_SIA eq 'NE') and (svval (TMP_RT#,TMP_VAR, N ) ne TMP_VALA ))   compute GOODCAT=1      |VALID VALUE
.       end if
.    end for
.    if then (GOODCAT=0)
.       display infobox "Dang, " +  pack(varlabsc(TMP_RT#,TMP_VAR))+ "can not be equal to that."
.       compute PASS1VAR=0
.    end if
|
. else if (vtype(TMP_RT#,TMP_VAR) eq 3)  |its a date so check the format.
.    compute TYPEDATE = upper(datemap(TMP_RT#,TMP_VAR))
.    compute TYPEDATE = replace(TYPEDATE,'M','d',4,1,0)
.    compute TYPEDATE = replace(TYPEDATE,'D','d',4,1,0)
.    compute TYPEDATE = replace(TYPEDATE,'Y','d',4,1,0)
.    compute TYPEDATE = replace(TYPEDATE,'/','x',4,1,0)
.    compute TYPEDATE = replace(TYPEDATE,'I','x',4,1,0) | SIRXS
.    compute TYPEDATE = replace(TYPEDATE,'E','' ,4,1,0) | SIRXS- exact
.    if (picture(TMP_VALA,TYPEDATE) ne 0)     compute PASS1VAR=0
.    if (miss(TMP_RT#,TMP_VAR,1) eq TMP_VALA) compute PASS1VAR=1
.    if (miss(TMP_RT#,TMP_VAR,2) eq TMP_VALA) compute PASS1VAR=1
.    if (miss(TMP_RT#,TMP_VAR,3) eq TMP_VALA) compute PASS1VAR=1
.    if (PASS1VAR=0) display infobox ["Opps, " + pack(varlabsc(TMP_RT#,TMP_VAR)) + " is:  "+datemap(TMP_RT#,TMP_VAR)]
|
. else if (vtype(TMP_RT#,TMP_VAR) eq 4)  |its a date so check the format.
.   compute TYPETIME = timemap(TMP_RT#,TMP_VAR)
.   compute TYPETIME = replace(TYPETIME,'H','d',4,1,0)
.   compute TYPETIME = replace(TYPETIME,'M','d',4,1,0)
.   compute TYPETIME = replace(TYPETIME,'S','d',4,1,0)
.   compute TYPETIME = replace(TYPETIME,'I','x',4,1,0)
.   compute TYPETIME = replace(TYPETIME,':','x',4,1,0)
.   compute TYPETIME = replace(TYPETIME,'E','',4,1,0)
.   if (picture(TMP_VALA,TYPETIME) ne 0)     compute PASS1VAR=0
.   if (miss(TMP_RT#,TMP_VAR,1) eq TMP_VALA) compute PASS1VAR=1
.   if (miss(TMP_RT#,TMP_VAR,2) eq TMP_VALA) compute PASS1VAR=1
.   if (miss(TMP_RT#,TMP_VAR,3) eq TMP_VALA) compute PASS1VAR=1
.   if (PASS1VAR=0) display infobox ["Opps, " +  pack(varlabsc(TMP_RT#,TMP_VAR)) + " is:  "+timemap(TMP_RT#,TMP_VAR)]
|
. else if (vtype(TMP_RT#,TMP_VAR) eq 5 or 6 or 7 or 8)  |its an integer
.    if then (exists(numbr(TMP_VALA))=0)
.       display infobox "Hey!  "+  pack(varlabsc(TMP_RT#,TMP_VAR)) + " must be a number!"
.       compute PASS1VAR=0
.    else if (nmax(TMP_RT#,TMP_VAR) lt numbr(TMP_VALA))
.       compute PASS1VAR=0
.         if (miss(TMP_RT#,TMP_VAR,1) eq TMP_VALA)  compute PASS1VAR=1
.         if (miss(TMP_RT#,TMP_VAR,2) eq TMP_VALA)  compute PASS1VAR=1
.         if (miss(TMP_RT#,TMP_VAR,3) eq TMP_VALA)  compute PASS1VAR=1
.       if (PASS1VAR=0) display infobox "Stop!  " +  pack(varlabsc(TMP_RT#,TMP_VAR))+ " must be below "+format(nmax(TMP_RT#,TMP_VAR))
.    else if (nmin(TMP_RT#,TMP_VAR) gt numbr(TMP_VALA))
.       compute PASS1VAR=0
.         if (miss(TMP_RT#,TMP_VAR,1) eq TMP_VALA)  compute PASS1VAR=1
.         if (miss(TMP_RT#,TMP_VAR,2) eq TMP_VALA)  compute PASS1VAR=1
.         if (miss(TMP_RT#,TMP_VAR,3) eq TMP_VALA)  compute PASS1VAR=1
.       if (PASS1VAR=0) display infobox "Stop! " +  pack(varlabsc(TMP_RT#,TMP_VAR)) + "The variable must be above "+format(nmin(TMP_RT#,TMP_VAR))
.    end if
. end if
. ifthen (len(TMP_VALA) GT 44)
.   display infobox "Too long. Can you make it shorter?: " +  pack(varlabsc(TMP_RT#,TMP_VAR))
.   compute PASS1VAR=0
. end if
|
. if( PASS1VAR EQ 0) compute PASSALL# = 0  | This is run for the entire variable list.  PASS1VAR gets reset to 1 for each var. PASSALL# is for the entire group.
end subprocedure
|
|
subprocedure INCLUDEB
ifthen (BRECTXT ne ARECTXT)
. write (seach_pql) '.     process rec ' BRECTXT
else
. write (seach_pql) '| 1st record and 2nd record were the same therefor no process rec here.'
endif
write (seach_pql) '.       compute KEYSTR$2 = ""'
ifthen (gettxt(B1_ADD) EQ '-')
. TMP_RT#  = BRECNUM
. TMP_VAR  = gettxt(B1VARN)
. TMP_SIA  = gettxt(B1SIGNA)
. TMP_VALA = gettxt(B1VALA)
. TMP_AND  = gettxt(B1AND)
. TMP_SIB  = gettxt(B1SIGNB)
. TMP_VALB = gettxt(B1VALB)
. execute subprocedure GET_VAR_INFO
endif
ifthen (gettxt(B2_ADD) EQ '-')
. TMP_RT#  = BRECNUM
. TMP_VAR  = gettxt(B2VARN)
. TMP_SIA  = gettxt(B2SIGNA)
. TMP_VALA = gettxt(B2VALA)
. TMP_AND  = gettxt(B2AND)
. TMP_SIB  = gettxt(B2SIGNB)
. TMP_VALB = gettxt(B2VALB)
. execute subprocedure GET_VAR_INFO
endif
ifthen (gettxt(B3_ADD) EQ '-')
. TMP_RT#  = BRECNUM
. TMP_VAR  = gettxt(B3VARN)
. TMP_SIA  = gettxt(B3SIGNA)
. TMP_VALA = gettxt(B3VALA)
. TMP_AND  = gettxt(B3AND)
. TMP_SIB  = gettxt(B3SIGNB)
. TMP_VALB = gettxt(B3VALB)
. execute subprocedure GET_VAR_INFO
endif
ifthen (gettxt(B4_ADD) EQ '-')
. TMP_RT#  = BRECNUM
. TMP_VAR  = gettxt(B4VARN)
. TMP_SIA  = gettxt(B4SIGNA)
. TMP_VALA = gettxt(B4VALA)
. TMP_AND  = gettxt(B4AND)
. TMP_SIB  = gettxt(B4SIGNB)
. TMP_VALB = gettxt(B4VALB)
. execute subprocedure GET_VAR_INFO
endif
ifthen ((gettxt(B5_ADD) EQ '-'))
. TMP_RT#  = BRECNUM
. TMP_VAR  = gettxt(B5VARN)
. TMP_SIA  = gettxt(B5SIGNA)
. TMP_VALA = gettxt(B5VALA)
. TMP_AND  = gettxt(B5AND)
. TMP_SIB  = gettxt(B5SIGNB)
. TMP_VALB = gettxt(B5VALB)
. execute subprocedure GET_VAR_INFO
endif
write (seach_pql) '|'
write (seach_pql) '.       ifthen (INC_RECX = 1)'
ifthen (nkeys(BRECNUM) gt 0)
. write (seach_pql) '.         compute KEYSTR$2 = "' [pack(recname(BRECNUM))] ':"'
. for n=2,nkeys(BRECNUM)+1
.   write (seach_pql) '.         compute KEYSTR$2 = KEYSTR$2 + "' [pack(keyname(BRECNUM,n))] '" + varget("' [pack(keyname(BRECNUM,n))] '")'  '+"<br>"'
. end for
endif
|
ifthen ((gettxt(C1_ADD) EQ '-')  or
        (gettxt(C2_ADD) EQ '-')  or
        (gettxt(C3_ADD) EQ '-'))  | Include the C record
. execute subprocedure INCLUDEC
else
| RECORD TYPE C IS NOT INCLUDED
. execute subprocedure SHOW_THE_DATA
endif
write (seach_pql) '.       endif'
ifthen (BRECTXT ne ARECTXT)
. write (seach_pql) '.     end rec'
endif
|
end subprocedure |B
|
|
subprocedure INCLUDEC
ifthen (CRECTXT ne BRECTXT)
. write (seach_pql) '.     process rec ' CRECTXT
else
. write (seach_pql) '| 1st record and 2nd record were the same therefor no process rec here.'
endif
ifthen (gettxt(C1_ADD) EQ '-')
. TMP_RT#  = CRECNUM
. TMP_VAR  = gettxt(C1VARN)
. TMP_SIA  = gettxt(C1SIGNA)
. TMP_VALA = gettxt(C1VALA)
. TMP_AND  = gettxt(C1AND)
. TMP_SIB  = gettxt(C1SIGNB)
. TMP_VALB = gettxt(C1VALB)
. execute subprocedure GET_VAR_INFO
endif
ifthen (gettxt(C2_ADD) EQ '-')
. TMP_RT#  = CRECNUM
. TMP_VAR  = gettxt(C2VARN)
. TMP_SIA  = gettxt(C2SIGNA)
. TMP_VALA = gettxt(C2VALA)
. TMP_AND  = gettxt(C2AND)
. TMP_SIB  = gettxt(C2SIGNB)
. TMP_VALB = gettxt(C2VALB)
. execute subprocedure GET_VAR_INFO
endif
ifthen (gettxt(C3_ADD) EQ '-')
. TMP_RT#  = CRECNUM
. TMP_VAR  = gettxt(C3VARN)
. TMP_SIA  = gettxt(C3SIGNA)
. TMP_VALA = gettxt(C3VALA)
. TMP_AND  = gettxt(C3AND)
. TMP_SIB  = gettxt(C3SIGNB)
. TMP_VALB = gettxt(C3VALB)
. execute subprocedure GET_VAR_INFO
endif
write (seach_pql) '|'
write (seach_pql) '.       ifthen (INC_RECX = 1)'
ifthen (nkeys(CRECNUM) gt 0)
. write (seach_pql) '.         compute KEYSTR$3 = "' [pack(recname(CRECNUM))] '"'
. for n=2,nkeys(CRECNUM)+1
.   write (seach_pql) '.         compute KEYSTR$3 = KEYSTR$3 + "' [pack(keyname(CRECNUM,n))] '" + varget("' [pack(keyname(CRECNUM,n))] '")'  '+"<br>"'
. end for
endif
execute subprocedure SHOW_THE_DATA
write (seach_pql) '.       endif'
ifthen (CRECTXT ne BRECTXT)
. write (seach_pql) '.     end rec'
endif
|
end subprocedure | INCLUDEC
|
|
|
subprocedure GET_VAR_INFO
c sample
C TMP_RT#  = ARECNUM
C TMP_VAR  = gettxt(A2VARN)
C TMP_SIA  = gettxt(A2SIGNA)
C TMP_VALA = gettxt(A2VALA)
c . compute USER_CRIT_2 = TMP_AND TMP_SIB TMP_VALB
. write (seach_pql) '.       get vars ' TMP_VAR
. TMP_VAR  = pack(TMP_VAR)
. TMP_VALA = upper(pack(TMP_VALA))
. TMP_VALB = upper(pack(TMP_VALB))
. ifthen (vtype(TMP_RT#, TMP_VAR) = 1)
.   USER_CRIT_1 = '(pack(upper(' + TMP_VAR + ')) ' + TMP_SIA + ' '
.   USER_CRIT_2 = '(pack(upper(' + TMP_VAR + ')) ' + TMP_SIB + ' '
. elseif (vtype(TMP_RT#, TMP_VAR) = 5 or 6 or 7 or 8)
.   USER_CRIT_1 = '(fst(' + TMP_VAR  + ',missing(' + TMP_VAR + ')) ' + TMP_SIA + ' '
.   USER_CRIT_2 = '(fst(' + TMP_VAR  + ',missing(' + TMP_VAR + ')) ' + TMP_SIB + ' '
. else | dates and times have missing values returned as strings, which goofs things up
.   USER_CRIT_1 = '('+ TMP_VAR + ' ' + TMP_SIA + ' '
.   USER_CRIT_2 = '('+ TMP_VAR + ' ' + TMP_SIB + ' '
. endif
. ifthen (vtype(TMP_RT#, TMP_VAR) = 1) |string add qoutes
.   USER_CRIT_1 = USER_CRIT_1 + '"' +TMP_VALA +'"'
.   USER_CRIT_2 = USER_CRIT_2 + '"' +TMP_VALB +'"'
. elseif (vtype(TMP_RT#, TMP_VAR) = 2) | categorical  because of a SIR2002 bug I MUST USE VARGET because it can be integer or string and I can not tell
.   USER_CRIT_1 = '(varget("' + TMP_VAR + '") ' +TMP_SIA + ' "'+ TMP_VALA + '"'
.   USER_CRIT_2 = '(varget("' + TMP_VAR + '") ' +TMP_SIB + ' "'+ TMP_VALB + '"'
. elseif (vtype(TMP_RT#, TMP_VAR) = 3) | Date
.   USER_CRIT_1 = USER_CRIT_1 + format(cdate(TMP_VALA, datemap(TMP_RT#,TMP_VAR)))
.   USER_CRIT_2 = USER_CRIT_2 + format(cdate(TMP_VALB, datemap(TMP_RT#,TMP_VAR)))
. elseif (vtype(TMP_RT#, TMP_VAR) = 4) | Time
.   USER_CRIT_1 = USER_CRIT_1 + format(ctime(TMP_VALA, timemap(TMP_RT#,TMP_VAR)))
.   USER_CRIT_2 = USER_CRIT_2 + format(ctime(TMP_VALB, timemap(TMP_RT#,TMP_VAR)))
. elseif (vtype(TMP_RT#, TMP_VAR) = 5 or 6 or 7  or 8) | Integer, Real (single precision), Real (double precision)
.   USER_CRIT_1 = USER_CRIT_1 + TMP_VALA
.   USER_CRIT_2 = USER_CRIT_2 + TMP_VALB
. endif
|
c was it missing... if so reverse whatever you need to.
. if (TMP_VALA EQ '') USER_CRIT_1  = '(misnum(' + TMP_VAR + ') '  + TMP_SIA + ' 0'
c TMP_VALA is NOT copied from above.  Because the default GUI value is blank and the user will get confused.  It is daring enough to do it for A.
| close the criteria.
. USER_CRIT_1 = USER_CRIT_1 + ')'
. USER_CRIT_2 = USER_CRIT_2 + ')'
. ifthen ( (TMP_VALB = '') or (getichk(SHOWMORE) EQ 0) )  |ie second variable is blank or SHOWMORE says show less
c write 'fix here'  | dang it... it is 2/9/2009 and I don't remember why I wrote 'fix here'.  Greg.
.   USER_CRIT_1 = '.        ifNOTthen (' +USER_CRIT_1 + ') | vtype='  + format(vtype(TMP_RT#, TMP_VAR))
. else
.   USER_CRIT_1 = '.        ifNOTthen (' +USER_CRIT_1 + ' ' + TMP_AND + ' ' + USER_CRIT_2 + ') | vtype='  + format(vtype(TMP_RT#, TMP_VAR))
. endif
. write (seach_pql) USER_CRIT_1
. USER_CRIT_1 =  '.          if(misnum(' + TMP_VAR +') eq 0) compute CNTMISS# = CNTMISS# + 1'
. write (seach_pql) USER_CRIT_1
. write (seach_pql) '.          compute INC_RECX = 0'
. write (seach_pql) '.        endif'
end subprocedure |GET_VAR_INFO
|
|
subprocedure SHOW_THE_DATA
. write (seach_pql) '.         write (seach_html) "<tr><td> Case is: " ' [pack(varname(0,1))] '  "<br>"  KEYSTR$1  KEYSTR$2 KEYSTR$3  "</td>"'
. do repeat XSHOW    = $A1_ADD$ $A2_ADD$ $A3_ADD$ $A4_ADD$ $A5_ADD$ $B1_ADD$ $B2_ADD$ $B3_ADD$ $B4_ADD$ $B5_ADD$  $C1_ADD$ $C2_ADD$ $C3_ADD$ /
            XRECN    = ARECN    ARECN    ARECN    ARECN    ARECN    BRECN    BRECN    BRECN    BRECN    BRECN     CRECN    CRECN    CRECN /
            XVARX    = A1VARN   A2VARN   A3VARN   A4VARN   A5VARN   B1VARN   B2VARN   B3VARN   B4VARN   B5VARN    C1VARN   C2VARN   C3VARN /
.   ifthen ( vtype(recnum(gettxt(XRECN)), gettxt(XVARX) ) = 5 or 6 or 7 or 8)
.     if (gettxt(XSHOW) eq '-') write (seach_pql) '.         write (seach_html) "<td>" "' [pack(gettxt(XVARX))]
                                '=" [fst( ' [pack(gettxt(XVARX))]
                                ',missing( ' [pack(gettxt(XVARX))]
                                '))] ":" [vallab(' [pack(gettxt(XVARX))]
                                ')] "<br>"'
.   else | dates and times have missing values returned as strings, which goofs things up.
.     if (gettxt(XSHOW) eq '-') write (seach_pql) '.         write (seach_html) "<td>" "' [pack(gettxt(XVARX))]
                                '=" '       [pack(gettxt(XVARX))]
                                '":" [vallab(' [pack(gettxt(XVARX))]
                                ')] "<br>"'
.   endif
. end repeat
. write (seach_pql) '.         write (seach_html) "</td></tr>"'
. write (seach_pql) '.         compute CNT_REC# = CNT_REC# + 1'
. write (seach_pql) '.         compute INCCASEX = 1'
end subprocedure |SHOW_THE_DATA
|
|
|
subprocedure CHK_ALL_VARS
| 1st check 1st values then re-check this with the 2nd values.  Remember each line can have 2 values to test.
. compute PASSALL# = 1 | Lets assume that the group of variables will pass the validation test
. do repeat XSHOW  = $A1_ADD$  $A2_ADD$  $A3_ADD$  $A4_ADD$  $A5_ADD$  $B1_ADD$  $B2_ADD$  $B3_ADD$  $B4_ADD$  $B5_ADD$  $C1_ADD$  $C2_ADD$  $C3_ADD$ /
            XRECN  = ARECN     ARECN     ARECN     ARECN     ARECN     BRECN     BRECN     BRECN     BRECN     BRECN     CRECN     CRECN     CRECN /
            XVARX  = A1VARN    A2VARN    A3VARN    A4VARN    A5VARN    B1VARN    B2VARN    B3VARN    B4VARN    B5VARN    C1VARN    C2VARN    C3VARN /
            XSIGNA = A1SIGNA   A2SIGNA   A3SIGNA   A4SIGNA   A5SIGNA   B1SIGNA   B2SIGNA   B3SIGNA   B4SIGNA   B5SIGNA   C1SIGNA   C2SIGNA   C3SIGNA /
            XVALA  = A1VALA    A2VALA    A3VALA    A4VALA    A5VALA    B1VALA    B2VALA    B3VALA    B4VALA    B5VALA    C1VALA    C2VALA    C3VALA
.   compute TMP_RT#  = recnum(gettxt(XRECN))
.   compute TMP_VAR  = gettxt(XVARX)    |temporary var to get the if statement below to work
.   compute TMP_SIA  = gettxt(XSIGNA)
.   compute TMP_VALA = gettxt(XVALA)
.   if (gettxt(XSHOW) eq '-')  execute subprocedure CHK_VALS         |Must pass in the RT# and TXTVAR1
. end repeat
| WARNING: I simply and use TMP_VALA for B variables!  It keeps it simple and it is correct too.
. do repeat XSHOW  = $A1_ADD$  $A2_ADD$  $A3_ADD$  $A4_ADD$  $A5_ADD$  $B1_ADD$  $B2_ADD$  $B3_ADD$  $B4_ADD$  $B5_ADD$  $C1_ADD$  $C2_ADD$  $C3_ADD$ /
            XRECN  = ARECN     ARECN     ARECN     ARECN     ARECN     BRECN     BRECN     BRECN     BRECN     BRECN     CRECN     CRECN     CRECN /
            XVARX  = A1VARN    A2VARN    A3VARN    A4VARN    A5VARN    B1VARN    B2VARN    B3VARN    B4VARN    B5VARN    C1VARN    C2VARN    C3VARN /
            XSIGNB = A1SIGNB   A2SIGNB   A3SIGNB   A4SIGNB   A5SIGNB   B1SIGNB   B2SIGNB   B3SIGNB   B4SIGNB   B5SIGNB   C1SIGNB   C2SIGNB   C3SIGNB /
            XVALB  = A1VALB    A2VALB    A3VALB    A4VALB    A5VALB    B1VALB    B2VALB    B3VALB    B4VALB    B5VALB    C1VALB    C2VALB    C3VALB
.   compute TMP_RT#  = recnum(gettxt(XRECN))
.   compute TMP_VAR  = gettxt(XVARX)    |temporary var to get the if statement below to work
.   compute TMP_SIA  = gettxt(XSIGNB)
.   compute TMP_VALA = gettxt(XVALB)
.   if (gettxt(XSHOW) eq '-')  execute subprocedure CHK_VALS         |Must pass in the RT# and TXTVAR1
. end repeat
end subprocedure |CHK_ALL_VARS
|
subprocedure CHANGE_AND_OR
. ifthen (gettxt(getfocus(0)) EQ 'And')
.   set item getfocus(0), 'Or'
. else
.   set item getfocus(0), 'And'
. endif
end subprocedure | CHANGE_AND_OR
|
|
subprocedure GET_COMPLEX
. do repeat XSHOW    = $A1_ADD$  $A2_ADD$  $A3_ADD$  $A4_ADD$ $A5_ADD$  $B1_ADD$  $B2_ADD$  $B3_ADD$  $B4_ADD$  $B5_ADD$  $C1_ADD$  $C2_ADD$  $C3_ADD$ /
            XAND     = A1AND     A2AND     A3AND     A4AND    A5AND     B1AND     B2AND     B3AND     B4AND     B5AND     C1AND     C2AND     C3AND    /
            XSIGN    = A1SIGNB  A2SIGNB  A3SIGNB  A4SIGNB A5SIGNB  B1SIGNB  B2SIGNB  B3SIGNB  B4SIGNB  B5SIGNB  C1SIGNB  C2SIGNB  C3SIGNB /
            XOTHER   = A1VALB   A2VALB   A3VALB   A4VALB  A5VALB   B1VALB   B2VALB   B3VALB   B4VALB   B5VALB   C1VALB   C2VALB   C3VALB  /
.   ifthen ( (gettxt(XSHOW) = '-') and
             (getichk(SHOWMORE) EQ 1) )
.     show item XAND
.     show item XSIGN
.     show item XOTHER
.   else
.     hide item XAND
.     hide item XSIGN
.     hide item XOTHER
.   endif
. end repeat
end subprocedure
end program
|}
END PROCEDURE
