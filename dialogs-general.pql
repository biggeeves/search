PROCEDURE      DIALOGS.GENERAL:T  (157471,50545)  |Last amended Dec 04, 2013,14:02:25
|| Generated by DP - don't edit anything outside |{...|}

|{ Header
| Creator:   Greg Neils
| Created:   Sometime in 2006
| Updated:   8/1/2008
| Retired:
| Called by: Toolbar and other database buttons
| Calls:     Every member in the SEARCH family
| Reason:    Everything you need to know about data in 1 nice spot
| Output:    Options to send output to an outside HTML file named after user.

program
ifthen (fileis(dsn('DBSLIST')) eq 1)
. compute X=GLOBALN('DBLIST',1)
else
. compute X=GLOBALN('DBLIST',0)
endif
end program
program
. string  * 100  TESTGLOB   | Does that global exist?
. integer *   1  DUMB_N#    | Cycle thru globals
. string  * 300  USER_FOL   | What is the output folder for the user
c disconnet master.  It runs faster
. compute MST_STAT = SYSTEM(38)
. compute X = GLOBALN('MSTSTAT',MST_STAT)
. if (MST_STAT eq 1) execute dbms 'CLEAR MASTER'
c sets the output folder to either a unique persons sign in and DB or there username
| set the output folder, and create it if necessary
| add the username to the path
. compute USER_FOL = dsn('PREFIX') + 'USERS\'
. if (fileis(USER_FOL) eq 0) compute CHK_DIR = makedir(USER_FOL) | NOT A DIRECTORY OR A FILE
. compute USER_FOL = USER_FOL + sglobal('USERA') +'\'
. if (fileis(USER_FOL) eq 0) compute CHK_DIR = makedir(USER_FOL) | NOT A DIRECTORY OR A FILE
|
| Define output Folders.  Add Username if possible to the path.
. execute dbms ["attribute seach_html filename='" + dsn('prefix')+ "USERS\Search"+getenv('username')+".html'"]
. execute dbms ["attribute seach_pql filename='" + dsn('prefix')+ "USERS\Search"+getenv('username')+".pql'"]
. for DUMB_N# = 1,system(53)
.   compute TESTGLOB = pack(globname(DUMB_N#))
.   ifthen (TESTGLOB eq 'USERA')
.     execute dbms ["attribute seach_html filename='" + dsn('prefix')+ "USERS\" + sglobal('USERA') +"\Search"+ sglobal('USERA') +".html'"]
.     execute dbms ["attribute seach_pql filename='" + dsn('prefix')+ "USERS\" + sglobal('USERA') +"\Search"+ sglobal('USERA') +".pql'"]
.     exit for
.   endif
. end for
. ifthen (len(dsn('seach_html')) gt 70)  | On local machines in 2002 names over 70 chars are a problem
.   ifthen (srst('<sirver>','XS') lt 1 )  | ie it is 2002... make sure to change it.
.     execute dbms ["attribute seach_html filename='" + appdir(0)+ "Search"+getenv('username')+".html'"]
.     execute dbms ["attribute seach_pql filename='" + appdir(0)+ "Search"+getenv('username')+".pql'"]
.   endif
. endif
|
end program
call SEARCH.INCLUDES.ALL_RECS
call SYSPROC.TOOLS.HTMLCODE  |sets html globals
c
program |crwarn
c
c print back noremarks nocommands
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 PLACE_HOLD_LABEL                ; preset PLACE_HOLD_LABEL                 (1 )
integer*1 B_FREQ                          ; preset B_FREQ                           (2 )
integer*1 B_CROSS                         ; preset B_CROSS                          (3 )
integer*1 B_SIMPLE                        ; preset B_SIMPLE                         (4 )
integer*1 B_COMPLEX                       ; preset B_COMPLEX                        (5 )
integer*1 B_FIND_TEXT                     ; preset B_FIND_TEXT                      (6 )
integer*1 REC1NAME                        ; preset REC1NAME                         (7 )
integer*1 REC1LINE                        ; preset REC1LINE                         (8 )
integer*1 SUMMARY                         ; preset SUMMARY                          (9 )
integer*1 L_TABLE                         ; preset L_TABLE                          (10 )
integer*1 T_PROG                          ; preset T_PROG                           (11 )
integer*1 SHOWKEYS                        ; preset SHOWKEYS                         (12 )
integer*1 ID_00028                        ; preset ID_00028                         (13 )
integer*1 XVAR                            ; preset XVAR                             (14 )
integer*1 XLAB                            ; preset XLAB                             (15 )
integer*1 FREQ_B                          ; preset FREQ_B                           (16 )
integer*1 SET_CT1                         ; preset SET_CT1                          (17 )
integer*1 SET_CT2                         ; preset SET_CT2                          (18 )
integer*1 CROSS_B                         ; preset CROSS_B                          (19 )
integer*1 VAR1NAME                        ; preset VAR1NAME                         (20 )
integer*1 VARLAB1                         ; preset VARLAB1                          (21 )
integer*1 SIGN1                           ; preset SIGN1                            (22 )
integer*1 VALUE1                          ; preset VALUE1                           (23 )
integer*1 VALLAB1                         ; preset VALLAB1                          (24 )
integer*1 ANDOR1                          ; preset ANDOR1                           (25 )
integer*1 VAR2NAME                        ; preset VAR2NAME                         (26 )
integer*1 VARLAB2                         ; preset VARLAB2                          (27 )
integer*1 SIGN2                           ; preset SIGN2                            (28 )
integer*1 VALUE2                          ; preset VALUE2                           (29 )
integer*1 VALLAB2                         ; preset VALLAB2                          (30 )
integer*1 T_RESULT                        ; preset T_RESULT                         (31 )
integer*1 CHK_LIST                        ; preset CHK_LIST                         (32 )
integer*1 CHK_TAB                         ; preset CHK_TAB                          (33 )
integer*1 MATCH_B                         ; preset MATCH_B                          (34 )
integer*1 L_3_1                           ; preset L_3_1                            (35 )
integer*1 L_3_2                           ; preset L_3_2                            (36 )
integer*1 L_3_3                           ; preset L_3_3                            (37 )
integer*1 L_3_4                           ; preset L_3_4                            (38 )
integer*1 L_3_5                           ; preset L_3_5                            (39 )
integer*1 L_SEARCH                        ; preset L_SEARCH                         (40 )
integer*1 T_CHOOSE                        ; preset T_CHOOSE                         (41 )
integer*1 FINDTEXT                        ; preset FINDTEXT                         (42 )
integer*1 CHK_DATA                        ; preset CHK_DATA                         (43 )
integer*1 CHK_CODE                        ; preset CHK_CODE                         (44 )
integer*1 CHK_PROG                        ; preset CHK_PROG                         (45 )
integer*1 THIS_REC                        ; preset THIS_REC                         (46 )
integer*1 WHOLEDB                         ; preset WHOLEDB                          (47 )
integer*1 EMC2                            ; preset EMC2                             (48 )
integer*1 IDVARLAB                        ; preset IDVARLAB                         (49 )
integer*1 IDNAME                          ; preset IDNAME                           (50 )
integer*1 IDVALLAB                        ; preset IDVALLAB                         (51 )
integer*1 IDVALUE                         ; preset IDVALUE                          (52 )
integer*1 SEARCH                          ; preset SEARCH                           (53 )
integer*1 ID_00031                        ; preset ID_00031                         (54 )
integer*1 L_4_3                           ; preset L_4_3                            (55 )
integer*1 L_4_OR                          ; preset L_4_OR                           (56 )
integer*1 L_2_F                           ; preset L_2_F                            (57 )
integer*1 L_2_CT                          ; preset L_2_CT                           (58 )
integer*1 L_2_VARS                        ; preset L_2_VARS                         (59 )
integer*1 L_2_LABS                        ; preset L_2_LABS                         (60 )
integer*1 SEL_LAB#                        ; preset SEL_LAB#                         (61 )
integer*1 L_ONOFF                         ; preset L_ONOFF                          (62 )
integer*1 SEL_REC                         ; preset SEL_REC                          (63 )
integer*1 SEL_VAR                         ; preset SEL_VAR                          (64 )
integer*1 SEL_VARL                        ; preset SEL_VARL                         (65 )
integer*1 SEL_SIGN                        ; preset SEL_SIGN                         (66 )
integer*1 SEL_ED                          ; preset SEL_ED                           (67 )
integer*1 ID_THISDB_PROCS                 ; preset ID_THISDB_PROCS                  (68 )
integer*1 ID_ALLDB_PROCS                  ; preset ID_ALLDB_PROCS                   (69 )
integer*1 ID_CHK_SPS                      ; preset ID_CHK_SPS                       (70 )
integer*1 ID_CHK_PQL                      ; preset ID_CHK_PQL                       (71 )
integer*1 LAB_C1$                         ; preset LAB_C1$                          (72 )
integer*1 LAB_C2$                         ; preset LAB_C2$                          (73 )
integer*1 ID_2_8                          ; preset ID_2_8                           (74 )
integer*1 ID_2_9                          ; preset ID_2_9                           (75 )
integer*1 L_3_OR                          ; preset L_3_OR                           (76 )
integer*1 ID_00032                        ; preset ID_00032                         (77 )
integer*1 VARINFO                         ; preset VARINFO                          (78 )
integer*1 SHOWKEYB                        ; preset SHOWKEYB                         (79 )
integer*1 SCHEM_1                         ; preset SCHEM_1                          (80 )
integer*1 SHOWGRID                        ; preset SHOWGRID                         (81 )
integer*1 NEXTSTEP                        ; preset NEXTSTEP                         (82 )
integer*1 ID_00037                        ; preset ID_00037                         (83 )
integer*1 ID_00033                        ; preset ID_00033                         (84 )
integer*1 ID_00034                        ; preset ID_00034                         (85 )
integer*1 ID_00036                        ; preset ID_00036                         (86 )
integer*1 ID_00038                        ; preset ID_00038                         (87 )
integer*1 ID_00039                        ; preset ID_00039                         (88 )
integer*1 SEL_LABR                        ; preset SEL_LABR                         (89 )
integer*1 SEL_LABV                        ; preset SEL_LABV                         (90 )
integer*1 LAB_SELL                        ; preset LAB_SELL                         (91 )
integer*1 LAB_C2TXT$                      ; preset LAB_C2TXT$                       (92 )
integer*1 LAB_C1TXT$                      ; preset LAB_C1TXT$                       (93 )
integer*1 SEARCH_DIR                      ; preset SEARCH_DIR                       (94 )
integer*1 m_page; preset m_page (1)

|{ Prologue
|}

dialog "Search the Database for Variables and Frequencies"

|{ Controls
postype 1
label    PLACE_HOLD_LABEL                ,  15,      112,   5, "TOP GREEN BAR"
button   B_FREQ                          ,  13,       35,  76, 0, "Frequencies"
button   B_CROSS                         ,  13,      119,  76, 0, "Crosstabs"
button   B_SIMPLE                        ,  13,      203,  76, 0, "Simple Query"
button   B_COMPLEX                       ,  13,      287,  76, 0, "Complex Query"
button   B_FIND_TEXT                     ,  13,      371,  76, 0, "Find Text"
list     REC1NAME                        ,  47,  98,  53, 104, 0
list     REC1LINE                        ,  47,  98, 160, 295, 0
edit     SUMMARY                         , 361,       72, 278, 0, 1
label    L_TABLE                         ,  36,       30, 118, "2. Pick a Table"
label    T_PROG                          , 364,       31,  40, "Progress"
text     SHOWKEYS                        ,  63,  81, 459,  76, 1
line     ID_00028                        ,   0, 408,   0, 567
list     XVAR                            , 180, 118,  53, 104, 0
list     XLAB                            , 180, 117, 160, 295, 0
button   FREQ_B                          , 308,       53, 138, 0, "Create Report"
button   SET_CT1                         , 305,       44,  90, 0, "Set Row    "
button   SET_CT2                         , 322,       44,  90, 0, "Set Column   "
button   CROSS_B                         , 338,       44,  90, 0, "Create report"
choice   VAR1NAME                        , 173,       53,  71
choice   VARLAB1                         , 173,      125, 155
choice   SIGN1                           , 173,      284,  38
edit     VALUE1                          , 173,      325,  55, 0, 0
choice   VALLAB1                         , 173,      381,  89
choice   ANDOR1                          , 200,       53,  60
choice   VAR2NAME                        , 226,       53,  71
choice   VARLAB2                         , 226,      125, 155
choice   SIGN2                           , 226,      284,  38
edit     VALUE2                          , 226,      325,  55, 0, 0
choice   VALLAB2                         , 226,      381,  89
label    T_RESULT                        , 255,       53,  77, "Show Results in a "
check    CHK_LIST                        , 265,       73,  40, "List"
check    CHK_TAB                         , 264,      141,  40, "Table"
button   MATCH_B                         , 287,       53, 105, 0, "Create Report"
label    L_3_1                           , 177,       30,  13, "3."
label    L_3_2                           , 204,       30,  13, "4."
label    L_3_3                           , 230,       30,  13, "5. "
label    L_3_4                           , 255,       30,  13, "6."
label    L_3_5                           , 291,       30,  13, "7."
label    L_SEARCH                        , 175,       30,  63, "2. Search for..."
label    T_CHOOSE                        , 197,       30,  63, "3. Choose"
edit     FINDTEXT                        , 172,       95, 132, 0, 0
radio    CHK_DATA                        , 197,       96,  65, " Data"
radio    CHK_CODE                        , 197,      243, 149, " Database codebook"
radio    CHK_PROG                        , 197,      422, 111, " Programming"
check    THIS_REC                        , 208,      106, 109, "(Fast) This Table"
check    WHOLEDB                         , 220,      106, 109, "(Slow) Entire Database"
check    EMC2                            , 244,      106, 109, "Exact match"
check    IDVARLAB                        , 208,      268, 136, "Variable - &Label"
check    IDNAME                          , 220,      268, 136, "Va&riable - Name"
check    IDVALLAB                        , 232,      268, 136, "&Value Labels"
check    IDVALUE                         , 244,      268, 136, "V&alues (Valid/Missing/Ranges)"
button   SEARCH                          , 268,       45,  91, 1, "Create Report"
line     ID_00031                        , 236,   1, 107,  32
label    L_4_3                           , 273,       30,  12, "4."
label    L_4_OR                          , 199,      201,  23, "OR"
label    L_2_F                           , 312,       30,  13, "3."
label    L_2_CT                          , 342,       31,  12, "5."
label    L_2_VARS                        , 170,       54,  97, "Variable name"
label    L_2_LABS                        , 170,      160,  73, "Description"
label    SEL_LAB#                        , 393,       31,  50, "Limit report to:"
choice   L_ONOFF                         , 389,       84,  40
choice   SEL_REC                         , 389,      139,  69
choice   SEL_VAR                         , 389,      218,  69
choice   SEL_VARL                        , 389,      289,  93
choice   SEL_SIGN                        , 389,      386,  32
edit     SEL_ED                          , 389,      425,  72, 0, 0
check    ID_THISDB_PROCS                 , 208,      431, 111, "This  DB's procfile only"
check    ID_ALLDB_PROCS                  , 220,      431, 111, "All  DB's procfiles"
check    ID_CHK_SPS                      , 248,      443,  87, "SPS files"
check    ID_CHK_PQL                      , 260,      443,  87, "*,pql,   *,pgm,   *,txt"
label    LAB_C1$                         , 309,      138,  53, ""
label    LAB_C2$                         , 326,      138,  53, ""
label    ID_2_8                          , 309,       31,  12, "3."
label    ID_2_9                          , 326,       31,  12, "4."
label    L_3_OR                          , 265,      118,  19, "Or"
line     ID_00032                        , 157,   1,  68, 140
button   VARINFO                         ,  13,      460,  52, 0, "Var Info"
button   SHOWKEYB                        ,  48,      459,  52, 0, "Show &Keys"
button   SCHEM_1                         ,  48,      515,  40, 0, "&Schema"
button   SHOWGRID                        , 387,      534,  28, 0, "Spreadsheet"
button   IDCLOSE                         ,   3,      533,  30, 0, "Exit"
button   NEXTSTEP                        , 395,        0,   0, 1, "HIDDEN"
label    ID_00037                        ,  16,       26,   7, "1."
label    ID_00033                        ,  15,      196,   5, "TOP GREEN BAR"
label    ID_00034                        ,  15,      280,   5, "TOP GREEN BAR"
label    ID_00036                        ,  15,      364,   5, "TOP GREEN BAR"
label    ID_00038                        , 380,       85,  38, "On / Off"
label    ID_00039                        , 380,       31,  50, "Optional:"
label    SEL_LABR                        , 380,      139,  62, "Table"
label    SEL_LABV                        , 380,      219,  64, "Variable"
label    LAB_SELL                        , 380,      290,  40, "Label"
label    LAB_C2TXT$                      , 326,      198, 233, "changes"
label    LAB_C1TXT$                      , 309,      198, 233, "changes"
label    SEARCH_DIR                      , 236,      431, 100, "Changes"
|}

initial
|{ Attribs
|< PLACE_HOLD_LABEL
. SET ITEM FONT PLACE_HOLD_LABEL,0,0,0, 0,"#77C01F/#77C01F"
|>
|< B_FREQ
. SET ITEM FONT B_FREQ,1,0,0, 1,""
|>
|< B_CROSS
. SET ITEM FONT B_CROSS,1,0,0, 1,""
|>
|< B_SIMPLE
. SET ITEM FONT B_SIMPLE,1,0,0, 1,""
|>
|< B_COMPLEX
. SET ITEM FONT B_COMPLEX,1,0,0, 1,""
|>
|< B_FIND_TEXT
. SET ITEM FONT B_FIND_TEXT,1,0,0, 1,""
|>
|< L_TABLE
. SET ITEM FONT L_TABLE,1,0,0, 1,"#00C000"
. SET ITEM FONT L_TABLE,1,0,0, 1,"#00C000"
|>
|< T_PROG
. SET ITEM FONT T_PROG,1,0,0, 0,"#005800"
|>
|< FREQ_B
. SET ITEM FONT FREQ_B,1,0,0, 1,""
. SET ITEM FONT FREQ_B,1,0,0, 1,""
|>
|< SET_CT1
. SET ITEM FONT SET_CT1,1,0,0, 1,""
|>
|< SET_CT2
. SET ITEM FONT SET_CT2,1,0,0, 1,""
|>
|< CROSS_B
. SET ITEM FONT CROSS_B,1,0,0, 1,""
. SET ITEM FONT CROSS_B,1,0,0, 1,""
|>
|< T_RESULT
. SET ITEM FONT T_RESULT,1,0,0, 0,"#990000"
|>
|< CHK_LIST
. SET ITEM FONT CHK_LIST,1,0,0, 1,""
|>
|< CHK_TAB
. SET ITEM FONT CHK_TAB,1,0,0, 1,""
|>
|< MATCH_B
. SET ITEM FONT MATCH_B,1,0,0, 1,""
. SET ITEM FONT MATCH_B,1,0,0, 1,""
|>
|< L_3_1
. SET ITEM FONT L_3_1,1,0,0, 1,"#00C000"
|>
|< L_3_2
. SET ITEM FONT L_3_2,1,0,0, 1,"#00C000"
|>
|< L_3_3
. SET ITEM FONT L_3_3,1,0,0, 1,"#00C000"
|>
|< L_3_4
. SET ITEM FONT L_3_4,1,0,0, 1,"#00C000"
|>
|< L_3_5
. SET ITEM FONT L_3_5,1,0,0, 1,"#00C000"
|>
|< L_SEARCH
. SET ITEM FONT L_SEARCH,1,0,0, 1,"#00C000"
|>
|< T_CHOOSE
. SET ITEM FONT T_CHOOSE,1,0,0, 1,"#00C000"
|>
|< CHK_DATA
. SET ITEM FONT CHK_DATA,1,0,0, 1,"#0000C0"
|>
|< CHK_CODE
. SET ITEM FONT CHK_CODE,1,0,0, 1,"#006000"
|>
|< CHK_PROG
. SET ITEM FONT CHK_PROG,1,0,0, 1,"#C00000"
|>
|< THIS_REC
. SET ITEM FONT THIS_REC,1,0,0, 0,""
|>
|< SEARCH
. SET ITEM FONT SEARCH,1,0,0, 1,""
. SET ITEM FONT SEARCH,1,0,0, 1,""
|>
|< L_4_3
. SET ITEM FONT L_4_3,1,0,0, 1,"#00C000"
|>
|< L_2_F
. SET ITEM FONT L_2_F,1,0,0, 1,"#5A0000"
. SET ITEM FONT L_2_F,1,0,0, 1,"#5A0000"
|>
|< L_2_CT
. SET ITEM FONT L_2_CT,1,0,0, 1,"#990000"
|>
|< L_2_VARS
. SET ITEM FONT L_2_VARS,1,0,0, 0,""
|>
|< L_2_LABS
. SET ITEM FONT L_2_LABS,1,0,0, 0,""
|>
|< SEL_LAB#
. SET ITEM FONT SEL_LAB#,0,0,0, 0,"#0000A2"
|>
|< LAB_C1$
. SET ITEM FONT LAB_C1$,1,0,0, 1,""
. SET ITEM FONT LAB_C1$,1,0,0, 1,""
|>
|< LAB_C2$
. SET ITEM FONT LAB_C2$,1,0,0, 1,""
. SET ITEM FONT LAB_C2$,1,0,0, 1,""
|>
|< ID_2_8
. SET ITEM FONT ID_2_8,1,0,0, 1,"#990000"
|>
|< ID_2_9
. SET ITEM FONT ID_2_9,1,0,0, 1,"#990000"
|>
|< VARINFO
. SET ITEM FONT VARINFO,1,0,0, 1,""
|>
|< ID_00037
. SET ITEM FONT ID_00037,1,0,0, 1,"#00C000"
. SET ITEM FONT ID_00037,1,0,0, 1,"#00C000"
|>
|< ID_00033
. SET ITEM FONT ID_00033,0,0,0, 0,"#77C01F/#77C01F"
|>
|< ID_00034
. SET ITEM FONT ID_00034,0,0,0, 0,"#77C01F/#77C01F"
|>
|< ID_00036
. SET ITEM FONT ID_00036,0,0,0, 0,"#77C01F/#77C01F"
|>
|< ID_00038
. SET ITEM FONT ID_00038,0,0,0, 0,"#0000A2"
|>
|< ID_00039
. SET ITEM FONT ID_00039,0,0,0, 0,"#0000A2"
|>
|< SEL_LABR
. SET ITEM FONT SEL_LABR,0,0,0, 0,"#0000A2"
|>
|< SEL_LABV
. SET ITEM FONT SEL_LABV,0,0,0, 0,"#0000A2"
|>
|< LAB_SELL
. SET ITEM FONT LAB_SELL,0,0,0, 0,"#0000A2"
|>
|< LAB_C2TXT$
. SET ITEM FONT LAB_C2TXT$,1,0,0, 1,""
. SET ITEM FONT LAB_C2TXT$,1,0,0, 1,""
|>
|< LAB_C1TXT$
. SET ITEM FONT LAB_C1TXT$,1,0,0, 1,""
. SET ITEM FONT LAB_C1TXT$,1,0,0, 1,""
|>
|< SEARCH_DIR
. SET ITEM FONT SEARCH_DIR,1,0,0, 0,""
|>

|}
|{ Init
integer *    1  MST_STAT           | Was master on?  If so reconnect at the end of the program
string  *  500  DBMS_STR           | This is used for execute DBMS such as
string  *  350  STR$3              | THIS IS WHAT PASSES the INFO ALONG TO the GENERAL
string  *  300  STR$1              | Record to search for search function
string  *   40  VARLAB1$           | Length of the appended variable label might have to incress for sir xs
string  *  300  HTMLLINE           | When exporting to view in a web browser this is the text
string  *  150  HTMLPATH           | View printable versions from the screen
string  *   12  TYPEDATE           | for checking date format in a MATCH
string  *   10  TYPETIME           | for checking time format in a MATCH
string  *    2  PUSHED             | WHAT DID THE USER PUSH????  |  T=TABLE  F=FIND  M=MATCH  S=SEARCH  CS=CODE+SEARCH   CT=CODE+TABLE
integer *    1  GOODCAT            | when checking to see if value is a valid catagorical value in MATCH
integer *    4  RT#                | record type #
integer *    1  PASSCLCK           | used for checking variables against schema
integer *    1  SHOWKEY$           | Whether or not to show the keys for the table.
integer *    1  MISS_#             | How many missning on a variable.  Used in for loops
integer *    2  NVARS_#            | # of Vars in a record
integer *    2  TMP_RT#            | error checking
string  *   35  TMP_VAR            | error checking
string  *   35  TMP_SIGN           | error checking
string  *   35  TMP_ED             | error checking
string  *   80  VARTEXT            | Used to get the variable name.  Used in atleast 2 locations.
string  *  200  PATTERNX           | What is the user looking for?
integer *    1  REFRESH$           | Do I need to refresh something.  If 1 then Yes.  Added as a temp fix.
string  *   25  FONT_1$            | Font for display
string  *   45  REC_NAME           | Recordy Type name
string  *   45  TXTVAR1            | 1st Variable name as text
string  *   45  TXTVAR2            | 2nd Variable name as text
integer *    4  DUMB_N#            | Integer to use whenever you want.
integer *    2  RESVAR             | User Directed Responses
string  *    1  TAB_TYPE           | Table type. Short List or Entire Table
string  *  100  MISS_$             | The string of the missing value
integer *    4  POSIT#1            | What position is it in the variable labels
integer *    1  NKEYS_#            | Number of keys in a record type
string  *  300  DB_PROCFILE        | What is the procfile you want to search?
string  *   32  DB_PROC_NAME       | What is the short name of the procfile (helpful when searching all procs)
string  *  300  SEARCH_STRING      | Search the procfile file for this string
integer *    2  CYCLE_DB           | How many DBs do we cycle through... searching the procfile
string  *   32  TXT_FAMILY_NAME    | Family name in the procfile
string  *   32  TXT_MEMBER_NAME    | Member name in the procfile
string  *  100  TXT_FULL_MEM_NAME  | fully qualified member name
integer *    4  MEMBER_LINE_NUMBER | What line number did we find the text on?
integer *    2  DUMBN#             | A large number, use whenever
integer *    2  F_COUNT            | Number of family names in the procfile
integer *    2  M_COUNT            | Number of member names in the procfile
string  *  400  MEM_TEXT           | Line in the member
string  *  200  STARTDIR FILEPATT  | Searching files and folders variables: Starting path, file ending
integer *    1  CASEMODE DIRPATH   | Searching files and folders variables: Case sensitive, Include folders and subfolders
integer *    4  FILESFND LINESFND  | Searching files and folders variables: Returned vars.  # files and lines found
set FONT_1$     ('Courier New')
set item font CROSS_B  ,1,0,0,3,FONT_1$
set item font FREQ_B   ,1,0,0,3,FONT_1$
set item font ID_2_8   ,1,0,0,3,FONT_1$
set item font ID_2_9   ,1,0,0,3,FONT_1$
set item font L_SEARCH ,1,0,0,3,FONT_1$
set item font L_TABLE  ,1,0,0,3,FONT_1$
set item font LAB_C1$  ,1,0,0,3,FONT_1$
set item font LAB_C2$  ,1,0,0,3,FONT_1$
set item font L_2_F    ,1,0,0,3,FONT_1$
set item font L_4_3    ,1,0,0,3,FONT_1$
set item font L_4_OR   ,1,0,0,3,FONT_1$
set item font L_3_1    ,1,0,0,3,FONT_1$
set item font L_3_2    ,1,0,0,3,FONT_1$
set item font L_3_3    ,1,0,0,3,FONT_1$
set item font L_3_4    ,1,0,0,3,FONT_1$
set item font L_3_5    ,1,0,0,3,FONT_1$
set item font L_2_CT   ,1,0,0,3,FONT_1$
set item font MATCH_B  ,1,0,0,3,FONT_1$
set item font REC1NAME ,1,0,0,3,FONT_1$
set item font REC1LINE ,1,0,0,3,FONT_1$
set item font SUMMARY  ,0,0,0,1,FONT_1$
set item font SEARCH   ,1,0,0,3,FONT_1$
set item font SET_CT1  ,1,0,0,3,FONT_1$
set item font SET_CT2  ,1,0,0,3,FONT_1$
set item font SEARCH   ,1,0,0,3,FONT_1$
set item font SHOWKEYS ,1,0,0,3,FONT_1$
set item font T_CHOOSE ,1,0,0,3,FONT_1$
set item font XVAR     ,1,0,0,3,FONT_1$
set item font XLAB     ,1,0,0,3,FONT_1$
hide item NEXTSTEP | Default button, I use it  to check for "enter" button
hide item SHOWGRID
|
compute SHOWKEY$ = 0
hide item SHOWKEYS
|
c SIGN
. do repeat X =  '=' '<' '<='  'NE' '>=' '>'
.   append item SIGN1,X
.   append item SIGN2,X
.   append item SEL_SIGN,X
. end repeat
C
|
c the skip and or
. do repeat X = 'Skip' 'And' 'Or'
.   append item ANDOR1,X
. end repeat                |Default is skip so disable second variable choices
|
. do repeat x = VAR2NAME, VARLAB2, SIGN2, VALLAB2, VALUE2
.   disable item x
. end repeat
|
. append item L_ONOFF,'Off'
. append item L_ONOFF,'On'
. execute subprocedure ONOFF$
|
. for I  = 1,nrecs(0)   |rec numbers for Selection Criteria
.   compute REC_NAME = trimlr(RECNAME(I))
.   ifnot (len(REC_NAME) GT 0) next for
.   append item REC1NAME,REC_NAME
.   append item REC1LINE,pack(recdoc(I,1))
.   append item SEL_REC, REC_NAME
. end for
|
. execute subprocedure SEL_AD_V
. compute PUSHED = 'T'   | Tricks it into loading some stuff up.
. execute subprocedure BRAINS
. check item   IDVARLAB
. check item   IDNAME
. disable item IDVARLAB
. disable item IDNAME
. disable item IDVALLAB
. disable item IDVALUE
. check item   THIS_REC
. check item   CHK_LIST
. set item     THIS_REC,'in '+gettxt(REC1NAME)
. hide item PLACE_HOLD_LABEL
. show item PLACE_HOLD_LABEL
. hide item B_FREQ
. hide item B_CROSS
. hide item B_SIMPLE
. hide item B_COMPLEX
. hide item B_FIND_TEXT
. show item B_FREQ
. show item B_CROSS
. show item B_SIMPLE
. show item B_COMPLEX
. show item B_FIND_TEXT
|
c set default search directory for searching through SPS, TXT, PQL, etc files
. STARTDIR = dsn('prefix')
. STARTDIR = substr(STARTDIR,1,len(STARTDIR)-1) | removes the first \ to go up a file
. STARTDIR = substr(STARTDIR,1,len(STARTDIR)+srst(reverse(STARTDIR),'\')+1)
. STARTDIR = fst(STARTDIR,"<GDATA1>")  |either the database folder or the entire Data1 Drive
. set item SEARCH_DIR, replace(STARTDIR,"\\192.168.53.246",'',1,1,1) | remove IP address and slashes
. disable item ID_CHK_SPS
. disable item ID_CHK_PQL
. disable item ID_THISDB_PROCS
. disable item ID_ALLDB_PROCS
|
|}
execute subprocedure page
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
|}

ifthen (m_id eq B_FREQ )
|< B_FREQ
. m_page = 1
. execute subprocedure PAGE
. compute PUSHED = 'F'
. focus item XVAR
|>
next message
endif

ifthen (m_id eq B_CROSS )
|< B_CROSS
. m_page = 2
. execute subprocedure PAGE
|
| Show things from page 1!!!!!!!  Tricky YES!
. show item L_2_VARS
. show item L_2_LABS
. show item XVAR
. show item XLAB
. focus item XVAR
|>
next message
endif

ifthen (m_id eq B_SIMPLE )
|< B_SIMPLE
. m_page = 3
. execute subprocedure PAGE
. focus item VAR1NAME
|>
next message
endif

ifthen (m_id eq B_COMPLEX )
|< B_COMPLEX
. execute dbms "call SEARCH.DIALOGS.QUERY"
|>
next message
endif

ifthen (m_id eq B_FIND_TEXT )
|< B_FIND_TEXT
. m_page = 4
. execute subprocedure PAGE
. focus item FINDTEXT
. ifthen (NGLOBAL('GSECLEV') EQ 1)
.   show item CHK_PROG
.   show item ID_ALLDB_PROCS
.   show item SHOWGRID
. else
.   hide item CHK_PROG
.   hide item ID_ALLDB_PROCS
.   hide item SHOWGRID
. endif

|>
next message
endif

ifthen (m_id eq REC1NAME )
|< REC1NAME
. select item REC1LINE,   getpos (REC1NAME)
. set item THIS_REC,'in '+gettxt(REC1NAME)
. compute PUSHED = 'T'
. set item LAB_C1$, ''
. set item LAB_C1TXT$, ''
. set item LAB_C2$, ''
. set item LAB_C2TXT$, ''
. execute subprocedure BRAINS
|>
next message
endif

ifthen (m_id eq REC1LINE )
|< REC1LINE
. select item REC1NAME,getpos (REC1LINE)
. set item THIS_REC,'in '+gettxt(REC1NAME)
. compute PUSHED = 'T'
. set item LAB_C1$, ''
. set item LAB_C1TXT$, ''
. set item LAB_C2$, ''
. set item LAB_C2TXT$, ''
. execute subprocedure BRAINS
|>
next message
endif

ifthen (m_id eq XVAR )
|< XVAR
. select item XLAB,getpos(XVAR)

. execute subprocedure PICKLIST

. ifthen (M_ARG2 eq 1)
.   compute PUSHED ='F'
.   execute subprocedure FREQ_CHK
.   if (PASSCLCK eq 0) next message
.   ifthen (gettxt(L_ONOFF) eq 'On')
.     execute subprocedure CHK_LIM
.     if (PASSCLCK eq 0) next message
.     execute subprocedure CHK_VALS
.     if (PASSCLCK eq 0) next message
.   endif
.   execute subprocedure BRAINS
. endif
|>
next message
endif

ifthen (m_id eq XLAB )
|< XLAB
| . compute TXTVAR1 = gettxt(XVAR)    |temporary var to get the if statement below to work

. select item XVAR,getpos(XLAB)  | Selects the same variable on left
. execute subprocedure PICKLIST  | Adds the value labels and other stuff
. ifthen (M_ARG2 eq 1)
.   compute PUSHED  = 'F'
.   execute subprocedure FREQ_CHK
.   if (PASSCLCK eq 0) next message
.   ifthen (gettxt(L_ONOFF) eq 'On')
.     execute subprocedure CHK_LIM
.     if (PASSCLCK eq 0) next message
.     execute subprocedure CHK_VALS
.     if (PASSCLCK eq 0) next message
.   endif
.   execute subprocedure BRAINS
. endif
|>
next message
endif

ifthen (m_id eq FREQ_B )
|< FREQ_B
. compute PUSHED  = 'F'
. execute subprocedure FREQ_CHK
. if (PASSCLCK eq 0) next message
. ifthen (gettxt(L_ONOFF) eq 'On')
.   execute subprocedure CHK_LIM
.   if (PASSCLCK eq 0) next message
.   execute subprocedure CHK_VALS
.   if (PASSCLCK eq 0) next message
. endif
. execute subprocedure BRAINS
|>
next message
endif

ifthen (m_id eq SET_CT1 )
|< SET_CT1
set item LAB_C1$,gettxt(XVAR)
set item LAB_C1TXT$,gettxt(XLAB)
|>
next message
endif

ifthen (m_id eq SET_CT2 )
|< SET_CT2
set item LAB_C2$,gettxt(XVAR)
set item LAB_C2TXT$,gettxt(XLAB)
|>
next message
endif

ifthen (m_id eq CROSS_B )
|< CROSS_B
. compute PUSHED  = 'C'
. execute subprocedure CROS_CHK
. if (PASSCLCK eq 0) next message
. ifthen (gettxt(L_ONOFF) eq 'On')
.   execute subprocedure CHK_LIM
.   if (PASSCLCK eq 0) next message
.   execute subprocedure CHK_VALS
.   if (PASSCLCK eq 0) next message
. endif
. execute subprocedure BRAINS
|>
next message
endif

ifthen (m_id eq VAR1NAME )
|< VAR1NAME
. execute subprocedure UPTOLIST
. select item VARLAB1, getpos (VAR1NAME)
. execute subprocedure LISTVAL1
|>
next message
endif

ifthen (m_id eq VARLAB1 )
|< VARLAB1
. execute subprocedure UPTOLIST
. select item VAR1NAME, getpos (VARLAB1)
. execute subprocedure LISTVAL1
|>
next message
endif

ifthen (m_id eq VALUE1 )
|< VALUE1
execute subprocedure SETVALL
c
|>
next message
endif

ifthen (m_id eq VALLAB1 )
|< VALLAB1
execute subprocedure SETVAL1
|>
next message
endif

ifthen (m_id eq ANDOR1 )
|< ANDOR1
execute subprocedure ANDOR1
|>
next message
endif

ifthen (m_id eq VAR2NAME )
|< VAR2NAME
. select item VARLAB2, getpos (VAR2NAME)
. select item XVAR,    getpos (VAR2NAME)
. select item XLAB,    getpos (VAR2NAME)
. execute subprocedure LISTVAL2
|>
next message
endif

ifthen (m_id eq VARLAB2 )
|< VARLAB2
. select item VAR2NAME, getpos (VARLAB2)
. select item XVAR,    getpos (VAR2NAME)
. select item XLAB,    getpos (VAR2NAME)
. execute subprocedure LISTVAL2
|>
next message
endif

ifthen (m_id eq VALUE2 )
|< VALUE2
. execute subprocedure SETVALL
|>
next message
endif

ifthen (m_id eq VALLAB2 )
|< VALLAB2
. execute subprocedure SETVAL2
|>
next message
endif

ifthen (m_id eq CHK_LIST )
|< CHK_LIST
uncheck item CHK_TAB
|>
next message
endif

ifthen (m_id eq CHK_TAB )
|< CHK_TAB
uncheck item CHK_LIST
|>
next message
endif

ifthen (m_id eq MATCH_B )
|< MATCH_B
compute PUSHED = 'M'
ifthen (getichk(CHK_LIST) eq 1)
. compute TAB_TYPE  = 'L'
elseif (getichk(CHK_TAB) eq 1)
. compute TAB_TYPE  = 'T'
endif
. compute TMP_RT#  = recnum(gettxt(REC1NAME))
. compute TMP_VAR  = gettxt(VAR1NAME)    |temporary var to get the if statement below to work
. compute TMP_SIGN = gettxt(SIGN1)
. compute TMP_ED   = trimlr(gettxt(VALUE1))
. execute subprocedure CHK_VALS         |Must pass in the RT# and TXTVAR1
. if (PASSCLCK eq 0) next message
. ifthen (gettxt(ANDOR1) ne 'Skip')
.   compute TMP_RT#  = recnum(gettxt(REC1NAME))
.   compute TMP_VAR  = gettxt(VAR2NAME)    |temporary var to get the if statement below to work
.   compute TMP_SIGN = gettxt(SIGN2)
.   compute TMP_ED   = trimlr(gettxt(VALUE2))
.   execute subprocedure CHK_VALS         |Must pass in the RT# and TXTVAR1
.   if (PASSCLCK eq 0) next message
. endif
|
. execute subprocedure BRAINS



|>
next message
endif

ifthen (m_id eq FINDTEXT )
|< FINDTEXT
. compute PUSHED = 'S'
|>
next message
endif

ifthen (m_id eq CHK_DATA )
|< CHK_DATA
. enable item THIS_REC
. enable item WHOLEDB
. enable item EMC2
. disable item IDVARLAB
. disable item IDNAME
. disable item IDVALLAB
. disable item IDVALUE
. disable item ID_THISDB_PROCS
. disable item ID_ALLDB_PROCS
. disable item ID_CHK_SPS
. disable item ID_CHK_PQL
|>
next message
endif

ifthen (m_id eq CHK_CODE )
|< CHK_CODE
. enable item IDVARLAB
. enable item IDNAME
. enable item IDVALLAB
. enable item IDVALUE
. disable item THIS_REC
. disable item WHOLEDB
. disable item EMC2
. disable item ID_THISDB_PROCS
. disable item ID_ALLDB_PROCS
. disable item ID_CHK_SPS
. disable item ID_CHK_PQL
|>
next message
endif

ifthen (m_id eq CHK_PROG )
|< CHK_PROG
. disable item THIS_REC
. disable item WHOLEDB
. disable item EMC2
. disable item IDVARLAB
. disable item IDNAME
. disable item IDVALLAB
. disable item IDVALUE
. enable item ID_THISDB_PROCS
. enable item ID_ALLDB_PROCS
. enable item ID_CHK_SPS
. enable item ID_CHK_PQL

|>
next message
endif

ifthen (m_id eq THIS_REC )
|< THIS_REC
uncheck item WHOLEDB
|>
next message
endif

ifthen (m_id eq WHOLEDB )
|< WHOLEDB
uncheck item THIS_REC
display infobox "If you search a single table it is MUCH faster!"
|>
next message
endif

ifthen (m_id eq SEARCH )
|< SEARCH
. compute PUSHED = 'S'
. execute subprocedure BRAINS
|>
next message
endif

ifthen (m_id eq L_ONOFF )
|< L_ONOFF
execute subprocedure ONOFF$
|>
next message
endif

ifthen (m_id eq SEL_REC )
|< SEL_REC
|qwert
execute subprocedure SEL_AD_V
|>
next message
endif

ifthen (m_id eq SEL_VAR )
|< SEL_VAR
. select item SEL_VARL, getpos (SEL_VAR)
|>
next message
endif

ifthen (m_id eq SEL_VARL )
|< SEL_VARL
. select item SEL_VAR, getpos (SEL_VARL)
|>
next message
endif

ifthen (m_id eq ID_THISDB_PROCS )
|< ID_THISDB_PROCS
. disable item THIS_REC
. disable item WHOLEDB
. disable item EMC2
. disable item IDVARLAB
. disable item IDNAME
. disable item IDVALLAB
. disable item IDVALUE
|>
next message
endif

ifthen (m_id eq ID_ALLDB_PROCS )
|< ID_ALLDB_PROCS
enable item ID_ALLDB_PROCS
|>
next message
endif

ifthen (m_id eq LAB_C1$ )
|< LAB_C1$
c changes as needed
|>
next message
endif

ifthen (m_id eq LAB_C2$ )
|< LAB_C2$
c changes as needed
|>
next message
endif

ifthen (m_id eq VARINFO )
|< VARINFO
. compute TXTVAR1 = gettxt(XVAR)
. execute subprocedure VARHELPS
|>
next message
endif

ifthen (m_id eq SHOWKEYB )
|< SHOWKEYB
ifthen (SHOWKEY$  eq 0)
. show item SHOWKEYS
. compute SHOWKEY$ = 1
else
. hide item SHOWKEYS
. compute SHOWKEY$ = 0
endif
|>
next message
endif

ifthen (m_id eq SCHEM_1 )
|< SCHEM_1
open seach_html /write / LRECL = 600
. compute STR$1  = '<' + CHAR(33) + 'DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">'
. write (seach_html) STR$1
. write (seach_html)  '<html>'
. write (seach_html)  '<head><style><!-- H6 { page-break-before : always ; } --></style></head>'
. write (seach_html)  '<body  bgcolor="#FFFFB0">'
. write (seach_html)  'Schema for <b>' [dbname(0)]  [datec(today(0),'mm/dd/yy')][timec(now(0),'hh:mm')] '</b>'
. write (seach_html)  "<b>*** Record " RT# "(" [pack(recname(RT#))] ") Definition ***</b>"
. write (seach_html)  '<hr>'
. write (seach_html)  '<br>'
. ifthen (dbtype(0) EQ 1)
.   compute TXTVAR1 = keyname(RT#,1)
.   write (seach_html)  '<br><b>Case ID.'  [trim(TXTVAR1)+","]  [pack(varlabsc(RT#,TXTVAR1))]'</b><br>'
.   execute subprocedure GET_FORMAT
. endif
. for NKEYS_# = 1,nkeys(RT#)
.   write (seach_html)  '<br>'
.   compute TXTVAR1 = keyname(RT#,dbtype(0) + NKEYS_#)
.   write (seach_html)  '<b>Key: ' [format(NKEYS_#)+ "."]  [trim(TXTVAR1)+","]  [pack(varlabsc(RT#,TXTVAR1))]'</b><br>'
.   execute subprocedure GET_FORMAT
. end for

. for NVARS_# = 1,nvarsc(RT#)
.   write (seach_html)  '<br>'
.   compute TXTVAR1 = varnamec(RT#,NVARS_#)
.   set DUMB_N# (0)
.   for KEY = 1,nkeys(RT#) + 1
.     if (keyname(RT#,KEY) eq TXTVAR1) set DUMB_N# (1); EXIT FOR
.   end for
.   if (DUMB_N# eq 1) next for
.   write (seach_html)  '<br>Variable ' [format(NVARS_#)+ "."]  '<b>' [trim(varnamec(RT#,NVARS_#))+","]  [pack(varlabsc(RT#,varnamec(RT#,NVARS_#)))]'</b><br>'
.   execute subprocedure GET_FORMAT
. end for
. write (seach_html)  '</body>'
write (seach_html)  '</html>'
close seach_html
compute DUMB_N# = help('file: "'+dsn('seach_html')+'"')

|>
next message
endif

ifthen (m_id eq SHOWGRID )
|< SHOWGRID
c . compute STR$="SIR SPREADSHEET RECTYPE="+gettxt(REC1NAME)+"/ labels"  |THIS DOES NOT WORK WITH MULTIUSER!
c . execute dbms  STR$
. compute PUSHED = 'TT'
. execute subprocedure BRAINS


|>
next message
endif

ifthen (m_id eq NEXTSTEP )
|< NEXTSTEP
ifthen (m_page eq 4)
. compute PUSHED = 'S'
. execute subprocedure BRAINS
endif
|>
next message
endif

if (m_id eq 0) exit message

end message

message VSCROLL m_id, m_arg1
|{ Scroll

ifthen (m_id eq REC1NAME )
|< REC1NAME
DUMBN$ = SETPOS(REC1LINE,M_ARG1)
|>
next message
endif

ifthen (m_id eq REC1LINE )
|< REC1LINE
DUMBN$ = SETPOS(REC1NAME,M_ARG1)
|>
next message
endif

ifthen (m_id eq XVAR )
|< XVAR
DUMBN$ = SETPOS(XLAB,M_ARG1)
|>
next message
endif

ifthen (m_id eq XLAB )
|< XLAB
DUMBN$ = SETPOS(XVAR,M_ARG1)
|>
next message
endif


|}
end message

end dialog
|{ Exit
c reconnect master as needed
. compute MST_STAT = <MSTSTAT>
. if (MST_STAT = 1) EXECUTE DBMS 'SET MASTER'
c
|}
|{ Pages
subprocedure page
.  hide item XVAR
.  hide item XLAB
.  hide item FREQ_B
.  hide item SET_CT1
.  hide item SET_CT2
.  hide item CROSS_B
.  hide item VAR1NAME
.  hide item VARLAB1
.  hide item SIGN1
.  hide item VALUE1
.  hide item VALLAB1
.  hide item ANDOR1
.  hide item VAR2NAME
.  hide item VARLAB2
.  hide item SIGN2
.  hide item VALUE2
.  hide item VALLAB2
.  hide item T_RESULT
.  hide item CHK_LIST
.  hide item CHK_TAB
.  hide item MATCH_B
.  hide item L_3_1
.  hide item L_3_2
.  hide item L_3_3
.  hide item L_3_4
.  hide item L_3_5
.  hide item L_SEARCH
.  hide item T_CHOOSE
.  hide item FINDTEXT
.  hide item CHK_DATA
.  hide item CHK_CODE
.  hide item CHK_PROG
.  hide item THIS_REC
.  hide item WHOLEDB
.  hide item EMC2
.  hide item IDVARLAB
.  hide item IDNAME
.  hide item IDVALLAB
.  hide item IDVALUE
.  hide item SEARCH
.  hide item ID_00031
.  hide item L_4_3
.  hide item L_4_OR
.  hide item L_2_F
.  hide item L_2_CT
.  hide item L_2_VARS
.  hide item L_2_LABS
.  hide item ID_THISDB_PROCS
.  hide item ID_ALLDB_PROCS
.  hide item ID_CHK_SPS
.  hide item ID_CHK_PQL
.  hide item LAB_C1$
.  hide item LAB_C2$
.  hide item ID_2_8
.  hide item ID_2_9
.  hide item L_3_OR
.  hide item LAB_C2TXT$
.  hide item LAB_C1TXT$
.  hide item SEARCH_DIR
.  ifthen (m_page EQ 1  )
.    show item XVAR
.    show item XLAB
.    show item FREQ_B
.    show item L_2_F
.    show item L_2_VARS
.    show item L_2_LABS
.  endif
.  ifthen (m_page EQ 2  )
.    show item SET_CT1
.    show item SET_CT2
.    show item CROSS_B
.    show item L_2_CT
.    show item LAB_C1$
.    show item LAB_C2$
.    show item ID_2_8
.    show item ID_2_9
.    show item LAB_C2TXT$
.    show item LAB_C1TXT$
.  endif
.  ifthen (m_page EQ 3  )
.    show item VAR1NAME
.    show item VARLAB1
.    show item SIGN1
.    show item VALUE1
.    show item VALLAB1
.    show item ANDOR1
.    show item VAR2NAME
.    show item VARLAB2
.    show item SIGN2
.    show item VALUE2
.    show item VALLAB2
.    show item T_RESULT
.    show item CHK_LIST
.    show item CHK_TAB
.    show item MATCH_B
.    show item L_3_1
.    show item L_3_2
.    show item L_3_3
.    show item L_3_4
.    show item L_3_5
.    show item L_3_OR
.  endif
.  ifthen (m_page EQ 4  )
.    show item L_SEARCH
.    show item T_CHOOSE
.    show item FINDTEXT
.    show item CHK_DATA
.    show item CHK_CODE
.    show item CHK_PROG
.    show item THIS_REC
.    show item WHOLEDB
.    show item EMC2
.    show item IDVARLAB
.    show item IDNAME
.    show item IDVALLAB
.    show item IDVALUE
.    show item SEARCH
.    show item ID_00031
.    show item L_4_3
.    show item L_4_OR
.    show item ID_THISDB_PROCS
.    show item ID_ALLDB_PROCS
.    show item ID_CHK_SPS
.    show item ID_CHK_PQL
.    show item SEARCH_DIR
.  endif
end subprocedure
|}

|{ Footer
c
subprocedure FIND_SCHEMA    |written by david baxter, modified by greg neils
. open seach_html   /write lrecl = 600
. write (seach_html) '<html>'
. write (seach_html) '<head>'
. write (seach_html) '<title>'
. write (seach_html) 'Results for your search'
. write (seach_html) '</title>'
. write (seach_html) '</head>'
. write (seach_html) '<body>'
. write (seach_html) '<table border=1 width="100%"><tr><td>'
. write (seach_html) '  <table  width="100%" border=0 bgcolor="#FFFFB0">'
. write (seach_html) '    <tr><td><p><big>Generated on ' [datec(today(0),'mm/dd/yy')]  ' at ' [timec(now(0),'hh:mm')] 'by ' [sglobal('USERA')]  ' and the D.C.C.</big></p></td></tr>'
. write (seach_html) '    <tr><td><p><b><big>Search db schema for: ' [gettxt(FINDTEXT)] '</big></b></p></td></tr>'
. write (seach_html) '    <tr><td><hr></td></tr>'
. write (seach_html) '  </table>'
. write (seach_html) '  <table border=1 CELLPADDING=6 CELLSPACING=0>'
. write (seach_html) '    <tr>'
. write (seach_html) '    <td bgcolor="#CCCCCC">Record</td>       <td bgcolor="#CCCCCC">Variable</td><td bgcolor="#CCCCCC">Variable Label</td>       <td bgcolor="#CCCCCC">Found</td>'
. write (seach_html) '    </tr>'
. compute PATTERNX  = '@' + upper(pack(gettxt(FINDTEXT))) + '@'
. for I  = 1, nrecs(0)   |rec numbers
.   compute REC_NAME = RECNAME(I)
.   ifnot (len(REC_NAME) gt 0) NEXT FOR
c check variable names
.   for NVARS_# = 1,NVARSC(I)
.     compute TXTVAR1 = VARNAMEC(I, NVARS_#)
.     ifthen (GETICHK(IDNAME) eq 1)
.       ifthen (pattern(upper(varnamec(I, NVARS_#)), PATTERNX) EQ 1)
.         write  (seach_html) '    <tr>'
.         write  (seach_html) '    <td>' REC_NAME '</td>'
.         write  (seach_html) '    <td>' TXTVAR1 '</td>'
.         write  (seach_html) '    <td>' [varlabsn(I, TXTVAR1, 1)] '</td>'
.         write  (seach_html) '    <td>' ["name:  " + varlabsc(I,VARNAMEC(I, NVARS_#))] '</td>'
.         write  (seach_html) '    </tr>'
.       endif
.     endif
c check full variable labels
.     ifthen (getichk(IDVARLAB) eq 1)
.       ifthen (pattern(upper(varlabsc(I, TXTVAR1)), PATTERNX) eq 1)
.         write  (seach_html) '    <tr>'
.         write  (seach_html) '    <td>' REC_NAME '</td>'
.         write  (seach_html) '    <td>' TXTVAR1 '</td>'
.         write  (seach_html) '    <td>' [varlabsc(I, TXTVAR1)] '</td>'
.         write  (seach_html) '    <td>' ["label: " + varlabsc(I, TXTVAR1)] '</td>'
.         write  (seach_html) '    </tr>'
.       endif
.     endif
c check value labels
.     ifthen (getichk(IDVALLAB) eq 1)
.       for K = 1, nvallab(I, TXTVAR1)
.         ifthen (pattern(upper(vallabsn(I, TXTVAR1, K)), PATTERNX) EQ 1)
.           write  (seach_html) '    <tr>'
.           write  (seach_html) '    <td>' REC_NAME '</td>'
.           write  (seach_html) '    <td>' TXTVAR1 '</td>'
.           write  (seach_html) '    <td>' [varlabsn(I, TXTVAR1, 1)] '</td>'
.           write  (seach_html) '    <td>' ["value: " + vallabsv(I, TXTVAR1, K) + ' ' + pack(vallabsn(I, TXTVAR1, K))] '</td>'
.           write  (seach_html) '    </tr>'
.         endif
.       end for
c .       compute TXTVAR1 = VARNAMEC(I, NVARS_#)  | this had to be added too.
c .       for K = 1,NVALID(I, TXTVAR1)      | This checks the valid value labels as well.  they are labels after all.
c .         ifthen (PATTERN(UPPER(vallabsn(I, TXTVAR1, K)),PATTERN) EQ 1)
c .  append item CODEINFO,"Rec: "+REC_NAME+" Var: " + pad(TXTVAR1," ",13,13)  +"  "+"value: "+ svval(I, TXTVAR1, K)+ ' '+vallabsn(I, TXTVAR1, K)
c .         endif
c .       end for
.     endif
c check values
.     ifthen (getichk(IDVALUE) EQ 1)
c check valid values
.       for K = 1,nvalid(I, TXTVAR1)
.         ifthen (pattern(upper(svval(I, TXTVAR1, K)),PATTERNX) EQ 1)
.           write  (seach_html) '    <tr>'
.           write  (seach_html) '    <td>' REC_NAME '</td>'
.           write  (seach_html) '    <td>' TXTVAR1 '</td>'
.           write  (seach_html) '    <td>' [varlabsn(I, TXTVAR1, 1)] '</td>'
.           write  (seach_html) '    <td>' ["valid value: "+ svval(I, TXTVAR1, K)+ ' '+vallabsn(I, TXTVAR1, K)] '</td>'
.           write  (seach_html) '    </tr>'
.         endif
.         ifthen (pattern(upper(format(nvval(I, TXTVAR1, K))),PATTERNX) EQ 1)
.           write  (seach_html) '    <tr>'
.           write  (seach_html) '    <td>' REC_NAME '</td>'
.           write  (seach_html) '    <td>' TXTVAR1 '</td>'
.           write  (seach_html) '    <td>' [varlabsn(I, TXTVAR1, 1)] '</td>'
.           write  (seach_html) '    <td>' ["valid value: "+ format(nvval(I, TXTVAR1, K))+' '+ vallabsn(I, TXTVAR1, K)] '</td>'
.           write  (seach_html) '    </tr>'
.         endif
.       end for
c check missing values
.       for K = 0,3
.         ifthen (pattern(upper(miss(I, TXTVAR1, K)),PATTERNX) EQ 1)
.           write  (seach_html) '    <tr>'
.           write  (seach_html) '    <td>' REC_NAME '</td>'
.           write  (seach_html) '    <td>' TXTVAR1 '</td>'
.           write  (seach_html) '    <td>' [varlabsn(I, TXTVAR1, 1)] '</td>'
.           write  (seach_html) '    <td>' "value: " [miss(I, TXTVAR1, K)+' '+VALLABSC(I, TXTVAR1,miss(I, TXTVAR1, K))] '</td>'
.           write  (seach_html) '    </tr>'
.         endif
.       end for
c check ranges
.        ifthen ((nmax(I, TXTVAR1) eq numbr(pack(gettxt(FINDTEXT)))) or (nmin(I, TXTVAR1) eq numbr(pack(gettxt(FINDTEXT)))))
.         write  (seach_html) '    <tr>'
.         write  (seach_html) '    <td>' REC_NAME '</td>'
.         write  (seach_html) '    <td>' TXTVAR1 '</td>'
.         write  (seach_html) '    <td>' [varlabsn(I, TXTVAR1, 1)] '</td>'
.         write  (seach_html) '    <td>' "range: "[ format(nmin(I, TXTVAR1))+' / ' +format(nmax(I, TXTVAR1))] '</td>'
.         write  (seach_html) '    </tr>'
.        endif
.     endif
.   end for
. end for
. write (seach_html) '  </table>'
. write (seach_html) '</table>'
. write (seach_html) '</body>'
. write (seach_html) '</html>'
. close (seach_html)
. DUMB_N# = help('file: "'+dsn('seach_html')+'"')
end subprocedure
|
|
|
subprocedure FIND_PROG    |written by david baxter, modified by greg neils
. open seach_html   /write lrecl = 600
. write (seach_html) '<html>'
. write (seach_html) '<head>'
. write (seach_html) '<title>'
. write (seach_html) 'Results for your programming search'
. write (seach_html) '</title>'
. write (seach_html) '</head>'
. write (seach_html) '<body>'
. write (seach_html) '<table border=1 width="100%"><tr><td>'
. write (seach_html) '  <table  width="100%" border=0 bgcolor="#FFFFB0">'
. write (seach_html) '    <tr><td><p><big>Generated on ' [datec(today(0),'mm/dd/yy')]  ' at ' [timec(now(0),'hh:mm')] 'by ' [sglobal('USERA')]  ' and the D.C.C.</big></p></td></tr>'
. write (seach_html) '    <tr><td><p><b><big>Search programs and procfiles for: ' [gettxt(FINDTEXT)] '</big></b></p></td></tr>'
. write (seach_html) '    <tr><td><hr></td></tr>'
. write (seach_html) '  </table>'
. write (seach_html) '  <table border=1 CELLPADDING=6 CELLSPACING=0>'
. write (seach_html) '    <tr>'
. write (seach_html) '    <td>Member or File Name</td><td>Line #</td><td>Line</td>'
. write (seach_html) '    </tr>'
| HERE GOES THE CODE
.   SEARCH_STRING = '@'+ upper(gettxt(FINDTEXT)) + '@'
|   GET A LIST OF SR4 FILES TO SEARCH
CIF EQ <DBLIST>,1 | compile the DCC DB list into the program
.   INCLUDE FILE DBSLIST  | READ LRECL = 600 IOSTAT = RC_DBSLIST
CIF END
|   SAMPLE LINE FROM DBSLIST
|   DB#C = DB#C+1; DB$N(DB#C) = 'ADRC';      DIR$(DB#C) = '<GDATA1>ADRC\Database\'
.   ifthen (getichk(ID_THISDB_PROCS) eq 1)
.     DB_PROC_NAME = ''
.     execute subprocedure SEARCH_PROCFILE
CIF EQ <DBLIST>, 1 | compile the DCC DB list into the program
.   elseif (getichk(ID_ALLDB_PROCS) eq 1)
.     for CYCLE_DB = 1, DB#C
.       DB_PROCFILE = DIR$(CYCLE_DB) + DB$N(CYCLE_DB)+ '.SR4'
.       DB_PROC_NAME = DB$N(CYCLE_DB)
.       if (fileis(DB_PROCFILE) ne 1) next for
.       DBMS_STR = "SET PROCFILE " + "'" + DB_PROCFILE + "'"
.       EXECUTE DBMS DBMS_STR
.       execute subprocedure SEARCH_PROCFILE
.     end for
CIF END
.   elseif (1 eq getichk(ID_CHK_SPS) or getichk(ID_CHK_PQL))
.     CASEMODE  = 0 | CASE INSENSTIVE
.     DIRPATH = 1 | include FOLDERS AND SUBFOLDERS
.     ifthen (getichk(ID_CHK_SPS) eq 1)
.       FILEPATT = ".sps"
.       execute subroutine SEARCH.INCLUDES.FILEBYNAME ( STARTDIR,FILEPATT,SEARCH_STRING, CASEMODE,DIRPATH   )
                                      returning (FILESFND,LINESFND)
.     endif
.     ifthen (getichk(ID_CHK_PQL) eq 1)
.       FILEPATT = ".pql"
.       execute subroutine SEARCH.INCLUDES.FILEBYNAME ( STARTDIR,FILEPATT,SEARCH_STRING, CASEMODE,DIRPATH   )
                                        returning (FILESFND,LINESFND)
.       FILEPATT = ".pgm"
.       execute subroutine SEARCH.INCLUDES.FILEBYNAME ( STARTDIR,FILEPATT,SEARCH_STRING, CASEMODE,DIRPATH   )
                                        returning (FILESFND,LINESFND)
.       FILEPATT = ".txt"
.       execute subroutine SEARCH.INCLUDES.FILEBYNAME ( STARTDIR,FILEPATT,SEARCH_STRING, CASEMODE,DIRPATH   )
                                        returning (FILESFND,LINESFND)
.     endif
.   else
.     display infobox 'Please check the boxes.  Something needs to be checked' | should not see this
.   endif
. write (seach_html) '  </table>'
. write (seach_html) '</table>'
. write (seach_html) '</body>'
. write (seach_html) '</html>'
. close (seach_html)
. DUMB_N# = help('file: "'+dsn('seach_html')+'"')
. execute dbms 'set procfile SIR014' | set the procfile back to the original procfile
end subprocedure |FIND_PROG
|
|
subprocedure SEARCH_PROCFILE
| SEARCH THE PROCEDURE FILE FOR THE TEXT
. for F_COUNT  = 1, system(57) | COUNT OF FAMILIES
.   TXT_FAMILY_NAME = famname(F_COUNT)
.   for M_COUNT = 1, memcount(TXT_FAMILY_NAME)
.     TXT_MEMBER_NAME = memname(TXT_FAMILY_NAME,M_COUNT)
.     TXT_FULL_MEM_NAME = TXT_FAMILY_NAME + '.' + TXT_MEMBER_NAME
.     if (meminfo(TXT_FULL_MEM_NAME ,1) NE 1) NEXT FOR
.     MEMBER_LINE_NUMBER = 0
.     open TEMP_PQL dsnvar=TXT_FULL_MEM_NAME member read lrecl = 254 iostat = RC
.       IF (RC NE 0) exit subprocedure
.       while (RC = 0)
.         read (TEMP_PQL,iostat = RC) MEM_TEXT (A254)
.         MEMBER_LINE_NUMBER = MEMBER_LINE_NUMBER+ 1
.         ifthen (PATTERN(MEM_TEXT,SEARCH_STRING) eq 1)
.           MEM_TEXT = upper(MEM_TEXT)
.           MEM_TEXT = replace(MEM_TEXT, '"', '', 99, 1, 0)
.           MEM_TEXT = replace(MEM_TEXT, "'", '', 99, 1, 0)
.           MEM_TEXT = replace(MEM_TEXT, "<", '', 99, 1, 0)
.           MEM_TEXT = replace(MEM_TEXT, ">", '', 99, 1, 0)
.           MEM_TEXT = replace(MEM_TEXT, "/", '', 99, 1, 0)
.           write (seach_html) '    <tr><td><strong>' DB_PROC_NAME '</strong>:' TXT_FULL_MEM_NAME '</td><td>' MEMBER_LINE_NUMBER '</td><td>' MEM_TEXT '</td></tr>'
.         endif
.       end while
.     close TEMP_PQL
.   end for
. end for
end subprocedure
|
subprocedure GET_INFO
c This gets the variable information to pass to the subroutine for Freqs and Lists and Cross
|
|
c VARIABLE 1
. ifthen (PUSHED eq 'F')
.   compute STR$3 = 'call  SEARCH.INCLUDES.FREQ ('
.   compute STR$3 = STR$3 + varname(0,1)                           |<1>
.   compute STR$3 = STR$3 + ','+format(recnum(gettxt(REC1NAME)))   |<2>
.   compute STR$3 = STR$3 +  ','+gettxt(XVAR)                       |<3>
.   compute STR$3 = STR$3 + ','                                     |<4>
.   compute STR$3 = STR$3 + ','                                     |<5>
.   compute STR$3 = STR$3 + ','                                     |<6>
c   varibale 2
.   execute subprocedure GET_LAB_C1$                            |<7>   | yes, this is substituing becuase Frequencies are for one variable only.
.   execute subprocedure GET_SIGN2                              |<8>
.   execute subprocedure GET_VALUE2                             |<9>
c   Selection criteria
.   execute subprocedure SEL_ADD
. elseif (PUSHED eq 'C')
.   compute STR$3 = 'call  SEARCH.INCLUDES.CROSS_TABS ('
.   compute STR$3 = STR$3 + varname(0,1)                            |<1>
.   compute STR$3 = STR$3 + ',' + format(recnum(gettxt(REC1NAME)))  |<2>
.   execute subprocedure GET_LAB_C1$                             |<3>
.   compute STR$3 = STR$3 + ','                                      |<4>
.   compute STR$3 = STR$3 + ','                                      |<5>
.   compute STR$3 = STR$3 + ','                                      |<6>
c   varibale 2
.   execute subprocedure GET_LAB_C2$                             |<7>
.   execute subprocedure GET_SIGN2                               |<8>
.   execute subprocedure GET_VALUE2                              |<9>
c   Selection criteria
.   execute subprocedure SEL_ADD
. elseif (PUSHED eq 'M')
.   ifthen (TAB_TYPE eq 'L')
.     compute STR$3 = 'call  SEARCH.INCLUDES.M_LIST (' |
.   elseif (TAB_TYPE  eq 'T')
.     compute STR$3 = 'call  SEARCH.INCLUDES.M_TABLE (' |
.   endif
.   compute STR$3 = STR$3+varname(0,1)                            |<1>
.   compute STR$3 = STR$3+','+format(recnum(gettxt(REC1NAME)))    |<2>
.   compute STR$3 = STR$3+','+gettxt(VAR1NAME)                    |<3>
.   execute subprocedure GET_SIGN1                              |<4>
.   execute subprocedure GET_VALUE1                             |<5>
.   execute subprocedure GET_ANDOR1                             |<6>
|   VARIABLE 2
.   ifthen ((gettxt(ANDOR1) ne 'Skip') and (PUSHED NE 'C'))
.     compute STR$3 = STR$3+','+gettxt(VAR2NAME)                  |<7>
.     execute subprocedure GET_SIGN2                            |<8>
.     execute subprocedure GET_VALUE2                           |<9>
.   elseif (PUSHED NE 'C') |have to pass it something or it doesn't run, what is passed is ignored at during the subroutine!
.     compute STR$3 = STR$3+','+gettxt(VAR1NAME)                  |<7>
.     execute subprocedure GET_SIGN1                            |<4> / <8> in this case
.     execute subprocedure GET_VALUE1                           |<5> / <9> in this case
.   endif
c   Selection criteria
.   execute subprocedure SEL_ADD
. endif
|
end subprocedure GET_INFO
|
|
|
subprocedure VARLIST    |displays all of the variables for both var 1 & 2
c This appends the variliables to the choice boxes based on the selected record
. execute subprocedure REMOVAL
. for NVARS_# = 1,nvarsc(RT#)                 |NVARS_#=numbered variables
.   compute TXTVAR1  = trimlr(varnamec(RT#,NVARS_#))
.   compute VARLAB1$ = pack(varlabsc(RT#,varnamec(RT#,NVARS_#)))
.   append item VAR1NAME, TXTVAR1
.   append item VAR2NAME, TXTVAR1
.   append item VARLAB1,  VARLAB1$
.   append item VARLAB2,  VARLAB1$
. end for
. execute subprocedure VALLIST1
. execute subprocedure VALLIST2
end subprocedure
|
|
|
subprocedure ANDOR1   |enables or disables variable 2
. ifthen (gettxt(ANDOR1) eq 'Skip')
.   do repeat X = VAR2NAME, VARLAB2, SIGN2, VALLAB2, VALUE2
.     disable item X
.   end repeat
. else
.   do repeat X = VAR2NAME, VARLAB2, SIGN2, VALLAB2, VALUE2
.     enable item X
.   end repeat
. endif
end subprocedure
|
|
|
subprocedure VARHELPS
. integer * 1 VARSPEC2  |GUI Control
. integer * 1 VIEWHTML  |GUI Control
. integer * 1 MYCLOSE   |GUI Control
. integer * 2 HID,HPOS,HDC | I don't really know but they are needed for the HElP GUI.
. VARSPEC2 = 1
. VIEWHTML = 2
. MYCLOSE  = 3
. dialog ["Variable Help: " + trim(recname(RT#)) + "." + TRIM(TXTVAR1) + " " + pack(varlabsc(RT#,TXTVAR1))]
. postype 1
. button VIEWHTML 155,0,80, 0 "View Printable"
. text   VARSPEC2 0,150,0,300,1
. button MYCLOSE 155,100,80, 1 "Close"
|
. initial
. set item font VARSPEC2 0,0,0,0,"Lucida Console"
. compute VARTEXT = trim(TXTVAR1)+":       "+pack(varlabsc(RT#,TXTVAR1))
. append line VARSPEC2,VARTEXT
|
| record name
. compute VARTEXT =        "Table:        " +recname(RT#)
. append line VARSPEC2,VARTEXT
. append line VARSPEC2,''
. c Type
. compute VARTEXT =      "Type:          "
. ifthen (vtype(RT#, TXTVAR1) eq 1) VARTEXT = VARTEXT + 'string'
. elseif (vtype(RT#, TXTVAR1) eq 2) VARTEXT = VARTEXT + 'categorical'
. elseif (vtype(RT#, TXTVAR1) eq 3) VARTEXT = VARTEXT + 'date'
. elseif (vtype(RT#, TXTVAR1) eq 4) VARTEXT = VARTEXT + 'time'
. elseif (vtype(RT#, TXTVAR1) eq 5) VARTEXT = VARTEXT + 'integer'
. elseif (vtype(RT#, TXTVAR1) eq 6) VARTEXT = VARTEXT + 'real (single precision)'
. elseif (vtype(RT#, TXTVAR1) eq 7) VARTEXT = VARTEXT + 'real (double precision)'
. elseif (vtype(RT#, TXTVAR1) eq 8) VARTEXT = VARTEXT + 'scaled variable'
. endif
. append line VARSPEC2,VARTEXT
. set VARTEXT (          "Format:        ")
. ifthen (vtype(RT#,TXTVAR1) eq 1) |  string
.   compute VARTEXT = VARTEXT + vformat (RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 2) |  categorical
.   compute VARTEXT = VARTEXT + vformat (RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 3) |  date
.   compute VARTEXT = VARTEXT + "A" + format (LEN(datemap(RT#,TXTVAR1)))
.   compute VARTEXT = VARTEXT + "  with date map: "+datemap(RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 4) |  time
.   compute VARTEXT = VARTEXT + "A" + format (LEN(TIMEMAP(RT#,TXTVAR1)))
.   compute VARTEXT = VARTEXT + "  with time map: "+TIMEMAP(RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 5) |  integer
.   compute VARTEXT = VARTEXT + vformat (RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 6) |  real (single precision)
.   compute VARTEXT = VARTEXT + vformat (RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 7) |  real (double precision)
.   compute VARTEXT = VARTEXT + vformat (RT#,TXTVAR1)
. elseif (vtype(RT#,TXTVAR1) eq 8) |  scaled variable
.   compute VARTEXT = VARTEXT + vformat (RT#,TXTVAR1)
. endif
. append line VARSPEC2,VARTEXT
. c Range
. ifthen (exists(nmin(RT#,TXTVAR1)))
.   ifthen (vtype(RT#,TXTVAR1) eq 3) |Date
.     compute VARTEXT =    "Range:         " + datec(nmin(RT#,TXTVAR1),datemap(RT#,TXTVAR1))+ " - "+ datec(nmax(RT#,TXTVAR1),datemap(RT#,TXTVAR1))
.     append line VARSPEC2,VARTEXT
.   elseif (vtype(RT#,TXTVAR1) eq 4)  |Time
.     compute VARTEXT =    "Range:         "+ timec(nmin(RT#,TXTVAR1),timemap(RT#,TXTVAR1))+ " - "+ timec(nmax(RT#,TXTVAR1),timemap(RT#,TXTVAR1))
.     append line VARSPEC2,VARTEXT
.   else
.     compute VARTEXT =    "Range:         "+format(nmin(RT#,TXTVAR1))+ " - "+ format(NMAX(RT#,TXTVAR1))
.     append line VARSPEC2,VARTEXT
.   endif
. elseif (exists(smin(RT#,TXTVAR1)))
.   compute VARTEXT =    "Range:         "+smin(RT#,TXTVAR1)+ " - " + SMAX(RT#,TXTVAR1)
.   append line VARSPEC2,VARTEXT
. endif
. c Missing
. for DUMB_N# = 1,3
.   ifthen (exists(miss(RT#, TXTVAR1, DUMB_N#)))
.     compute MISS_$ = miss(RT#, TXTVAR1, DUMB_N#)
.     if(trim(MISS_$) eq "") set MISS_$("BLANK")
.     compute VARTEXT =    "Missing Value " + format(DUMB_N#) +" :    " + MISS_$
.     append line VARSPEC2, VARTEXT
.   endif
. end for
. c Value Labels
. ifthen (nvallab(RT#,TXTVAR1) GT 0)
.   append line VARSPEC2, "Value Labels:  "
.   for I = 1,nvallab(RT#,TXTVAR1)
.     compute VARTEXT = "(" + vallabsv(RT#, TXTVAR1, I)+")  " + vallabsn(RT#, TXTVAR1, I)
.     append line VARSPEC2, VARTEXT
.   end for
. endif
c valid values
. ifthen (nvalid(RT#,TXTVAR1) GT 0)
.   append line VARSPEC2, "Valid Values:  "
.   for I = 1,nvalid(RT#, TXTVAR1)
.     ifthen (vtype(RT#, TXTVAR1) = 2)
.       compute VARTEXT = "   " + svval(RT#, TXTVAR1, I)
.       append line VARSPEC2,VARTEXT
.     elseif (vtype(RT#,TXTVAR1) = 5)
.       compute VARTEXT = "   " + format(nvval(RT#, TXTVAR1, I))
.       append line VARSPEC2, VARTEXT
.     endif
.   end for
. endif
end initial
|
|
|
. messages all HID,HPOS,HDC
. ifthen (HID eq VIEWHTML)
.   open seach_html   /write lrecl = 600
.   write (seach_html) '<html>'
.   write (seach_html) '<head>'
.   write (seach_html) '<title>'
.   write (seach_html) 'Your Request'
.   write (seach_html) '</title>'
.   write (seach_html) '</head>'
.   write (seach_html) '<body>'
.   write (seach_html) '<table border=1 CELLPADDING=6 CELLSPACING=0>'
.   close htmlpath
.   for N = 1, getnline(VARSPEC2)
.     compute HTMLLINE  = '<tr><td bgcolor="99FFFF">'
.     write  (seach_html) HTMLLINE
.     compute HTMLLINE = replace(getltxt(VARSPEC2, n), ':' , '</TD><TD>' , 1, 0, 0)
.     write  (seach_html) HTMLLINE
.     write  (seach_html) '</td></tr>'
.   end for
.   write (seach_html) '</table>'
.   write (seach_html) '</body>'
.   write (seach_html) '</html>'
.   close (seach_html)
.   compute DUMB_N# = help('file: "' + dsn('seach_html') + '"')
.   exit message
. endif
. ifthen (hid eq MYCLOSE)
.   exit message
. endif
. if (hid eq 0) exit message
. end messages
. end dialog
end subprocedure
|
|
|
subprocedure REMOVAL
.  remove all VAR1NAME
.  remove all VARLAB1
.  remove all VALUE1
.  remove all VALLAB1
.  remove all VAR2NAME
.  remove all VALLAB2
.  remove all VALUE2
.  remove all VARLAB2
end subprocedure
|
|
|
subprocedure PICKLIST
. ifthen (gettxt(ANDOR1) eq 'Skip')
.   select item VAR1NAME,getpos(XVAR)
.   select item VARLAB1, getpos(XVAR)
.   execute subprocedure LISTVAL1
.   execute subprocedure SETVALL
. else
.   display popup list ("Match Variable &1",
                      "Match Variable &2")
                      AT VAR1NAME, 1 POSTYPE 0
                      response RESVAR
|
.   ifthen (RESVAR eq 1)
.     select item VAR1NAME, getpos(XVAR)
.     select item VARLAB1, getpos(XVAR)
.     execute subprocedure LISTVAL1
.     execute subprocedure SETVALL
.   elseif (RESVAR eq 2)
.     select item VAR2NAME, getpos(XVAR)
.     select item VARLAB2, getpos(XVAR)
.     enable item ANDOR1
.     select item ANDOR1, 2
.     execute subprocedure ANDOR1
.     execute subprocedure LISTVAL2
.     execute subprocedure SETVALL
.   endif
. endif
end subprocedure PICKLIST
|
|
|
subprocedure BRAINS
| brains here
. RT#      = recnum(gettxt(REC1NAME))  |this can also be recalculated in PUSHED = 'CS' because they can choose a new record there.
. REC_NAME = recname(RT#)
. ifthen (PUSHED = 'T')
.   set item SUMMARY,format(numrecs(RT#)) + " recs," + format(nvarsc(RT#)) + ' vars'
.   remove all SHOWKEYS
.   for NKEYS_# = 1,nkeys(RT#) + 1
.     append line SHOWKEYS, keyname(RT#, NKEYS_#)
.   end for
.   remove all XVAR
.   remove all XLAB
.   for NVARS_# = 1, nvarsc(RT#)
.       append item XVAR, trimlr(varnamec(RT#, NVARS_#))
.       append item XLAB, pack(varlabsc(RT#, varnamec(RT#, NVARS_#)))
.   end for
.   execute subprocedure VARLIST
|
. elseif (PUSHED eq 'F')
.   execute subprocedure GET_INFO
.   execute dbms STR$3
|
. elseif (PUSHED eq 'C')
.   execute subprocedure GET_INFO
.   execute dbms STR$3
|
. elseif (PUSHED eq 'M')
.   execute subprocedure GET_INFO
.   execute dbms STR$3
|
. elseif (PUSHED eq 'S')
.   ifthen(getichk(CHK_CODE) eq 1)
.     execute subprocedure FIND_SCHEMA
.   elseif(getichk(CHK_DATA) eq 1)
.     REFRESH$ = 1
.     ifthen (pack(gettxt(FINDTEXT)) ne '')
.       ifthen (exists(gettxt(FINDTEXT)) ne 0)
.         compute STR$1 = ''
.         ifthen (getichk(WHOLEDB)  = 1)
.           execute DBMS "call SEARCH.INCLUDES.ALLRECS"
.         else | Set the globals for 1 record type
.           DUMB_N# = globals('GREC1', format(recnum(gettxt(REC1NAME))))
.           DUMB_N# = globals('GREC2', '')
.           DUMB_N# = globals('GREC3', '')
.           DUMB_N# = globals('GREC4', '')
.         endif
.         compute STR$3 = 'call SEARCH.INCLUDES.TEXTS (' + gettxt(FINDTEXT) + ',' + format(getichk(EMC2)) + ')'
.         execute dbms STR$3
.       else
.         display infobox "Please enter searchable text"
.         REFRESH$ = 0
.       endif
.     else
.       display infobox "Please enter searchable text"
.       REFRESH$ = 0
.     endif
.   elseif(getichk(CHK_PROG) eq 1)
.     execute subprocedure FIND_PROG
.   endif
.   if(REFRESH$ eq 1) execute subprocedure VARLIST
. elseif (PUSHED eq 'TT')
.   STR$1 = format(recnum(gettxt(REC1NAME)))
.   DUMB_N# = globals('RECLIST', STR$1)
.   execute dbms 'call SEARCH.INCLUDES.SPREAD'
. elseif (PUSHED eq 'CD')
.   STR$1 = format(recnum(gettxt(REC1NAME)))
.   DUMB_N# = globals('RECLIST', STR$1)
.   execute dbms 'call SEARCH.INCLUDES.CHK_DIGI'
. endif
|
end subprocedure BRAINS
|
|
|
subprocedure FREQ_CHK
. compute PASSCLCK = 1  |lets assume everything is all right.
. compute TXTVAR1 = gettxt(XVAR)    |temporary var to get the if statement below to work
. if(exists(TXTVAR1) eq 0) TXTVAR1 = ''
end subprocedure FREQ_CHK
|
|
|
subprocedure CROS_CHK
. compute PASSCLCK = 1  |lets assume everything is all right.
. ifthen( (gettxt(LAB_C1$) eq '') or (gettxt(LAB_C2$) eq ''))
.   compute PASSCLCK = 0
.   display infobox "Opps, 2 Items must be picked"
. endif
. compute TXTVAR1 = gettxt(LAB_C1$) |temporary var to get the if statement below to work
. compute TXTVAR2 = gettxt(LAB_C2$) |temporary var to get the if statement below to work
. ifthen (vtype(RT#, TXTVAR1) eq 1 or 3)
.   display infobox "Sorry, There is no Cross Tabs for " + TXTVAR1
.   compute PASSCLCK = 0
. endif
. ifthen (vtype(RT#, TXTVAR2) eq 1 or 3 )
.   display infobox "Sorry, There is no Cross Tabs for " + TXTVAR2
.   compute PASSCLCK = 0
. endif
end subprocedure CROS_CHK
|
|
|
subprocedure LISTVAL1
. remove all VALUE1
. remove all VALLAB1
. execute subprocedure VALLIST1
end subprocedure LISTVAL1
|
|
|
subprocedure LISTVAL2
. remove all VALUE2
. remove all VALLAB2
. execute subprocedure VALLIST2
end subprocedure LISTVAL2
|
|
|
subprocedure VALLIST1   |appends all value labels to variable 1
. compute TXTVAR1 = gettxt(VAR1NAME)
. ifthen (nvallab(RT#, TXTVAR1) GT 0)   |1st try value labels and it will only show things with value labels (it will ignore ranges)
.    for K = 1,nvallab(RT#, TXTVAR1)              |K=numbered value labels
.       append item VALLAB1,vallabsn(RT#, TXTVAR1, K)
.    end for
.    append item VALLAB1,''
. elseif (nvalid(RT#, TXTVAR1) GT 0)
.    for N = 1,nvalid(RT#, TXTVAR1)
.       if (vtype(RT#, TXTVAR1) = 2)   append item VALLAB1, svval ( RT#, TXTVAR1, n)
.       if (vtype(RT#, TXTVAR1) = 5)   append item VALLAB1, nvval ( RT#, TXTVAR1, n)
.    end for
. elseif ((exists(nmin(RT#, TXTVAR1))) and (exists(nmax(RT#, TXTVAR1))))
c .    if not then(vtype(RT#,TXTVAR1) eq 3 OR 4) |DATE AND TIMES SHOULD NOT HAVE THE RANGE APPENDED
.      ifthen (nmax(RT#, TXTVAR1) - nmin(RT#, TXTVAR1) lt 400)
.        for n = nmin(RT#, TXTVAR1), nmax(RT#, TXTVAR1)
.           append item VALLAB1, N
.        end for
.      endif
c .    endif
. endif
. execute subprocedure SETVAL1
end subprocedure VALLIST1
|
|
|
subprocedure VALLIST2   |appends all value labels to variable 2
. compute TXTVAR2 = gettxt(VAR2NAME)
. ifthen (nvallab(RT#, TXTVAR2) GT 0)   |1st try value labels
.    for K = 1, nvallab(RT#, TXTVAR2)              |K=numbered value labels
.       append item VALLAB2, vallabsn(RT#, TXTVAR2, K)
.    end for
. elseif (nvalid(RT#, TXTVAR2) GT 0)    |2nd try valid values
.    for N = 1, nvalid(RT#, TXTVAR2)
.       if (vtype(RT#, TXTVAR2) = 2)   append item VALLAB2, svval ( RT#, TXTVAR2, N)
.       if (vtype(RT#, TXTVAR2) = 5)   append item VALLAB2, nvval ( RT#, TXTVAR2, N)
.    end for
. elseif ((exists(nmin(RT#, TXTVAR2))) and (exists(nmax(RT#,TXTVAR2))))
c .    if not then(vtype(RT#, TXTVAR2) eq 3 OR 4) |DATE AND TIMES SHOULD NOT HAVE THE RANGE APPENDED
.      ifthen (nmax(RT#, TXTVAR2) - nmin(RT#, TXTVAR2) lt 400)
.        for n = nmin(RT#, TXTVAR2), nmax(RT#, TXTVAR2)
.           append item VALLAB2, N
.        end for
.      endif
c .    endif
. endif
. execute subprocedure SETVAL2
end subprocedure
|
|
|
subprocedure SETVALL   |SET VALUE LABELS
|   variable 1
. ifthen (validate(RT#, gettxt(VAR1NAME), gettxt(VALUE1)) EQ 4 OR 5 OR 6)
.   ifthen (substr(vschfmt( RT#, gettxt(VAR1NAME)), 1, 6) EQ 'DATE:E')
.     write 'SORRY MISSING VALUES ON EXACT DATES DO NOT WORK WELL'
.   else
.     compute POSIT#1 = vallabsp (RT#, gettxt(VAR1NAME), gettxt(VALUE1))
.   endif
. else
.   compute POSIT#1 = vallabsp (RT#, gettxt(VAR1NAME), gettxt(VALUE1))
. endif
. ifthen (gettxt(VALUE1) eq '')  |blank
.   select item VALLAB1, nvallab(RT#, gettxt(VAR1NAME))+1
. elseif (POSIT#1 ne 0)
.   select item VALLAB1, POSIT#1
. else
.   POSIT#1 = nvallab(RT#, gettxt(VAR1NAME))+1
.   select item VALLAB1, POSIT#1
. endif
|   variable 2
. compute POSIT#1 = vallabsp (RT#, gettxt(VAR2NAME), gettxt(value2))
. ifthen (gettxt(VALUE2) eq '')  |blank
.   select item VALLAB2, nvallab(RT#, gettxt(VAR2NAME))+1
. elseif (POSIT#1 ne 0)
.   select item VALLAB2, POSIT#1
. else
.   POSIT#1 = nvallab(RT#, gettxt(VAR2NAME))+1
.   select item VALLAB2, POSIT#1
. endif
end subprocedure |SETVALL
|
|
|
subprocedure SETVAL1 |SET ACTUAL VALUE
. for K = 1, nvallab(RT#, pack(gettxt(VAR1NAME)))              |K=numbered value labels
.   if (pack(vallabsn(RT#, gettxt(VAR1NAME), K)) eq pack(gettxt(VALLAB1))) compute POSIT#1 = K
. end for
. ifthen (nvallab(RT#, gettxt(VAR1NAME)) gt 0)
.   set item VALUE1, vallabsv (RT#, gettxt(VAR1NAME), POSIT#1)
. else
.   set item VALUE1, gettxt(VALLAB1)
. endif
. if (gettxt(VALLAB1) eq '') set item VALUE1, ''
end subprocedure |SETVAL1
|
|
|
subprocedure SETVAL2 |SET ACTUAL VALUE
. for K = 1, nvallab(RT#, gettxt(VAR2NAME))              |K=numbered value labels
.   if (pack(vallabsn(RT#, gettxt(VAR2NAME), K)) eq pack(gettxt(VALLAB2))) compute POSIT#1 = K
. end for
. ifthen (nvallab(RT#, gettxt(VAR2NAME)) GT 0)   |add check for the last value in the list it would be the '' kind work here!!!!!!!!!!!!!!
.   set item VALUE2,    vallabsv (RT#, gettxt(VAR2NAME), POSIT#1)
. else
.   set item VALUE2,  gettxt(VALLAB2)
. endif
. if (gettxt(VALLAB2) eq '') set item VALUE2, ''
end subprocedure
|
|
|
subprocedure UPTOLIST
. select item XLAB, getpos (VARLAB1)
. select item XVAR, getpos (VARLAB1)
end subprocedure |UPTOLIST
|
|
|
subprocedure CHK_VALS   | RT#, SIGN$, TXTVAR1, EDITVAL  ALL MUST BE PASSED TO THIS PROCEDURE
c write TMP_RT# TMP_VAR TMP_SIGN TMP_ED
. compute PASSCLCK = 1  |lets assume everything is all right.
. ifthen ((TMP_SIGN eq '=') and (TMP_ED eq '') )
.    |PASSCLCK stays the same
. elseif ((TMP_ED eq '') and (TMP_SIGN ne '='))
.    display infobox "Opps, you need to use =  for blanks"
.    compute PASSCLCK = 0
. elseif (vtype(TMP_RT#, TMP_VAR) eq 1)  | string
.    ifthen (numbr(substr(vformat(TMP_RT#, TMP_VAR), 1, len(vformat(TMP_RT#, TMP_VAR)))) gt len(TMP_ED))
.       display infobox 'Boggie, That is too long for the variable'
.       compute PASSCLCK = 0
.    endif
. elseif (vtype(TMP_RT#, TMP_VAR) eq 2)  | catagorical
.    compute GOODCAT = 0
.    for N = 1, nvalid(TMP_RT#, TMP_VAR)  |must cycle thru and get values instead of use "catint"
.       ifthen ((TMP_SIGN eq '<')  and (svval (TMP_RT#, TMP_VAR,  N ) <  TMP_ED ))   compute GOODCAT = 1      |VALID VALUE
.       elseif ((TMP_SIGN eq '<=') and (svval (TMP_RT#, TMP_VAR,  N ) <= TMP_ED ))   compute GOODCAT = 1      |VALID VALUE
.       elseif ((TMP_SIGN eq '=')  and (svval (TMP_RT#, TMP_VAR,  N ) =  TMP_ED ))   compute GOODCAT = 1      |VALID VALUE
.       elseif ((TMP_SIGN eq '>=') and (svval (TMP_RT#, TMP_VAR,  N ) >= TMP_ED ))   compute GOODCAT = 1      |VALID VALUE
.       elseif ((TMP_SIGN eq '>')  and (svval (TMP_RT#, TMP_VAR,  N ) >  TMP_ED ))   compute GOODCAT = 1      |VALID VALUE
.       elseif ((TMP_SIGN eq 'NE') and (svval (TMP_RT#, TMP_VAR,  N ) ne TMP_ED ))   compute GOODCAT = 1      |VALID VALUE
.       endif
.    end for
.    ifthen (GOODCAT eq 0)
.       display infobox "Dang, The variable can not be equal to that."
.       compute PASSCLCK = 0
.    endif
. elseif (vtype(TMP_RT#,TMP_VAR) eq 5 or 6 or 7 or 8)  |its an integer
.    ifthen (exists(numbr(TMP_ED)) = 0)
.       display infobox "Hey!  The variable must be a number!"
.       compute PASSCLCK = 0
.    elseif (nmax(TMP_RT#, TMP_VAR) lt numbr(TMP_ED))
.       compute PASSCLCK = 0
.         if (miss(TMP_RT#, TMP_VAR, 1) eq TMP_ED)  compute PASSCLCK = 1
.         if (miss(TMP_RT#, TMP_VAR, 2) eq TMP_ED)  compute PASSCLCK = 1
.         if (miss(TMP_RT#, TMP_VAR, 3) eq TMP_ED)  compute PASSCLCK = 1
.       if (PASSCLCK eq 0) display infobox "Stop!  The variable must be below "+format(nmax(TMP_RT#, TMP_VAR))
.    elseif (nmin(TMP_RT#, TMP_VAR) gt numbr(TMP_ED))
.       compute PASSCLCK = 0
.         if (miss(TMP_RT#, TMP_VAR, 1) eq TMP_ED)  compute PASSCLCK = 1
.         if (miss(TMP_RT#, TMP_VAR, 2) eq TMP_ED)  compute PASSCLCK = 1
.         if (miss(TMP_RT#, TMP_VAR, 3) eq TMP_ED)  compute PASSCLCK = 1
.       if (PASSCLCK eq 0) display infobox "Stop!  The variable must be above "+format(nmin(TMP_RT#, TMP_VAR))
.    endif
. elseif (vtype(TMP_RT#, TMP_VAR) eq 3)  |its a date so check the format.
.    compute TYPEDATE = datemap(TMP_RT#, TMP_VAR)
.    compute TYPEDATE = replace(TYPEDATE, 'M', 'd', 4, 1, 0)
.    compute TYPEDATE = replace(TYPEDATE, 'D', 'd', 4, 1, 0)
.    compute TYPEDATE = replace(TYPEDATE, 'Y', 'd', 4, 1, 0)
.    compute TYPEDATE = replace(TYPEDATE, '/', 'x', 4, 1, 0)
.    compute TYPEDATE = replace(TYPEDATE, 'I', 'x', 4, 1, 0)
.    compute TYPEDATE = replace(TYPEDATE, 'E', '' , 4, 1, 0)
.    compute TYPEDATE =  trimlr(TYPEDATE)
.    if (picture(TMP_ED, TYPEDATE) ne 0)   compute PASSCLCK = 0; write tmp_ed,  typedate [picture(TMP_ED, TYPEDATE)]
.    if (miss(TMP_RT#, TMP_VAR, 1) eq TMP_ED)  compute PASSCLCK = 1
.    if (miss(TMP_RT#, TMP_VAR, 2) eq TMP_ED)  compute PASSCLCK = 1
.    if (miss(TMP_RT#, TMP_VAR, 3) eq TMP_ED)  compute PASSCLCK = 1
.    if (PASSCLCK eq 0) display infobox ["Opps, variable IS  "+datemap(TMP_RT#, TMP_VAR)]
. elseif (vtype(TMP_RT#, TMP_VAR) eq 4)  |its a date so check the format.
.   compute TYPETIME = timemap(TMP_RT#, TMP_VAR)
.   compute TYPETIME = replace(TYPETIME, 'H', 'd', 4, 1, 0)
.   compute TYPETIME = replace(TYPETIME, 'M', 'd', 4, 1, 0)
.   compute TYPETIME = replace(TYPETIME, 'S', 'd', 4, 1, 0)
.   compute TYPETIME = replace(TYPETIME, ':', 'x', 4, 1, 0)
.   if (picture(TMP_ED, TYPETIME) ne 0)  compute PASSCLCK = 0
.   if (miss(TMP_RT#, TMP_VAR, 1) eq TMP_ED)  compute PASSCLCK = 1
.   if (miss(TMP_RT#, TMP_VAR, 2) eq TMP_ED)  compute PASSCLCK = 1
.   if (miss(TMP_RT#, TMP_VAR, 3) eq TMP_ED)  compute PASSCLCK = 1
.   if (PASSCLCK eq 0) display infobox ["Opps,  variable IS  "+timemap(TMP_RT#, TMP_VAR)]
. endif
. ifthen ((vtype(TMP_RT#, TMP_VAR) eq 5) and (gettxt(SIGN1) NE '='))
.   for N = 1, 3
.     ifthen (miss(TMP_RT#, TMP_VAR, n) eq TMP_ED)
.       display infobox "Opps,  =   Must be used when looking for missing values..."
.       compute PASSCLCK = 0
.     endif
.   end for
. elseif (len(TMP_ED) GT 44)
.   display infobox "Too Much,  I can not search for things that big"
.   compute PASSCLCK = 0
. endif
c
end subprocedure
|
|
|
subprocedure ONOFF$
. ifthen (gettxt(L_ONOFF) eq 'On')
.   enable item SEL_REC
.   enable item SEL_VAR
.   enable item SEL_VARL
.   enable item SEL_SIGN
.   enable item SEL_ED
. else
.   disable item SEL_REC
.   disable item SEL_VAR
.   disable item SEL_VARL
.   disable item SEL_SIGN
.   disable item SEL_ED
. endif
end subprocedure |ONOFF$
|
|
|
subprocedure SEL_ADD
. ifthen (gettxt(L_ONOFF) eq 'On')
.   compute STR$3 = STR$3 + ',  '
.   compute STR$3 = STR$3 + format(recnum(gettxt(SEL_REC))) |<10>
.   compute STR$3 = STR$3 + ',  '
.   compute STR$3 = STR$3 + gettxt(SEL_VAR)                 |<11>
.   compute STR$3 = STR$3 + ','
.   compute STR$3 = STR$3 + gettxt(SEL_SIGN)                |<12>
.   compute STR$3 = STR$3 + ','
.   compute STR$3 = STR$3 + pack(gettxt(SEL_ED))+')'        |<13>
. else
.   compute STR$3 = STR$3 + ','
.   compute STR$3 = STR$3 + format(recnum(gettxt(SEL_REC))) |<10>  A VALID RECORD NUMBER MUST BE PASSED
.   compute STR$3 = STR$3 + ','
.   compute STR$3 = STR$3 + varnamec(0,1)                   |<11>
.   compute STR$3 = STR$3 + ','
.   compute STR$3 = STR$3 + gettxt(SEL_SIGN)                |<12>
.   compute STR$3 = STR$3 + ','
.   compute STR$3 = STR$3 + 'GREG WAS HERE)'                |<13>  NO SELECTION CRITERIA WAS APPLIED
. endif
. end subprocedure
|
|
|
subprocedure SEL_AD_V   |Adds Variables to the drop down list in the SELECTION Criteria area.
. remove all SEL_VAR
. remove all SEL_VARL
. remove all SEL_ED
. compute RT# = recnum(gettxt(SEL_REC))
. for NVARS_# = 1, nvarsc(RT#)                 |NVARS_#=numbered variables
.   compute TXTVAR1  = varnamec(RT#, NVARS_#)
.   compute VARLAB1$ = pack(varlabsc(RT#, varnamec(RT#, NVARS_#)))
.   append item SEL_VAR, TXTVAR1
.   append item SEL_VARL, VARLAB1$
. end for
end subprocedure
|
|
|
subprocedure CHK_LIM
. ifthen (gettxt(SEL_SIGN) ne '=')
.   if (gettxt(SEL_ED) eq '') display infobox 'Blank only works with the = sign'
.   if (miss(recnum(gettxt(SEL_REC)), gettxt(SEL_VAR), 1) eq gettxt(SEL_ED)) display infobox 'User defined missing values must use the = sign.';PASSCLCK = 0
.   if (miss(recnum(gettxt(SEL_REC)), gettxt(SEL_VAR), 2) eq gettxt(SEL_ED)) display infobox 'User defined missing values must use the = sign.';PASSCLCK = 0
.   if (miss(recnum(gettxt(SEL_REC)), gettxt(SEL_VAR), 3) eq gettxt(SEL_ED)) display infobox 'User defined missing values must use the = sign.';PASSCLCK = 0
. endif
. compute TMP_RT#  = recnum(gettxt(SEL_REC))
. compute TMP_VAR  = gettxt(SEL_VAR)    |temporary var to get the subprocedure below to work
. compute TMP_SIGN = gettxt(SEL_SIGN)
. compute TMP_ED   = gettxt(SEL_ED)
end subprocedure
|
|
subprocedure GET_FORMAT
c
c Range
c
. ifthen (exists(nmin(RT#, TXTVAR1)))
.   ifthen (vtype(RT#, TXTVAR1) eq 3) |  date
.     compute STR$1 = "Range:"+datec(nmin(RT#, TXTVAR1), 'mm/dd/yyyy')+ " - " + datec(nmax(RT#, TXTVAR1), 'mm/dd/yyyy')
.     write (seach_html)  STR$1  '<br>'
.   elseif (vtype(RT#, TXTVAR1) eq 4) |  time
.     compute STR$1 = "Range:          "+timec(nmin(RT#, TXTVAR1), 'hh:mm')+ " - " + timec(nmax(RT#, TXTVAR1), 'hh:mm')
.     write (seach_html)  STR$1  '<br>'
.   else
.     compute STR$1 = "Range:          "+format(nmin(RT#, TXTVAR1))+ " - " + format(nmax(RT#, TXTVAR1))
.     write (seach_html)  STR$1  '<br>'
.   endif
. elseif (exists(smin(RT#, TXTVAR1)))
.   compute STR$1 = "Range:          "+smin(RT#, TXTVAR1)+ " - " + smax(RT#, TXTVAR1)
.   write (seach_html)  STR$1  '<br>'
. endif
c
c Missing
c
. for DUMB_N# = 1, 3
.   ifthen (exists(miss(RT#, TXTVAR1, DUMB_N#)))
.     compute MISS_$ = miss(RT#, TXTVAR1, DUMB_N#)
.     if(trim(MISS_$) eq "") set MISS_$("BLANK")
.     compute VARTEXT =    "Missing Value " + format(DUMB_N#) +" :    " + MISS_$
.     write (seach_html)  VARTEXT
.   endif
. end for
c
c Value Labels
c
. ifthen (nvallab(RT#, TXTVAR1) gt 0)
.   compute STR$1 = "Value Labels:"
.   for I = 1, nvallab(RT#, TXTVAR1)
.     compute STR$1 = STR$1 + "("+vallabsv(RT#, TXTVAR1, I)+")  " + VALLABSN(RT#, TXTVAR1, I)
.     write (seach_html)  STR$1 '<br>'
.     compute STR$1 = ""
.   end for
. endif
. write (seach_html)
c
c Type
c
. set STR$1 ("Format: ")
. ifthen (vtype(RT#, TXTVAR1) eq 1) |  string
.   compute STR$1 = STR$1 + vformat (RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 2) |  categorical
.   compute STR$1 = STR$1 + vformat (RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 3) |  date
.   compute STR$1 = STR$1 + "A" + format (len(datemap(RT#, TXTVAR1)))
.   compute STR$1 = STR$1 + "  with date map: "+datemap(RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 4) |  time
.   compute STR$1 = STR$1 + "A" + format (len(TIMEMAP(RT#, TXTVAR1)))
.   compute STR$1 = STR$1 + "  with time map: "+TIMEMAP(RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 5) |  integer
.   compute STR$1 = STR$1 + vformat (RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 6) |  real (single precision)
.   compute STR$1 = STR$1 + vformat (RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 7) |  real (double precision)
.   compute STR$1 = STR$1 + vformat (RT#, TXTVAR1)
. elseif (vtype(RT#, TXTVAR1) eq 8) |  scaled variable
.   compute STR$1 = STR$1 + vformat (RT#, TXTVAR1)
. endif
. write (seach_html)  STR$1
end subprocedure
|
subprocedure GET_LAB_C1$ |<3> or <7>  Depends
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(LAB_C1$)) eq 1)
.   compute STR$3 = STR$3 + gettxt(LAB_C1$)
. else
.   compute STR$3 = STR$3 + ""
. endif
end subprocedure
|
subprocedure GET_LAB_C2$ |<7>
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(LAB_C2$)) eq 1)
.   compute STR$3 = STR$3 + gettxt(LAB_C2$)
. else
.   compute STR$3 = STR$3 + ""
. endif
end subprocedure
|
subprocedure GET_SIGN1 |<4>
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(SIGN1)) eq 1)
.   compute STR$3 = STR$3 + gettxt(SIGN1)
. else
.   compute STR$3 = STR$3 + "="
. endif
end subprocedure
|
subprocedure GET_SIGN2 |<8>
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(SIGN2)) eq 1)
.   compute STR$3 = STR$3 + gettxt(SIGN2)
. else
.   compute STR$3 = STR$3 + "="
. endif
end subprocedure
|
subprocedure GET_VALUE1 |<5>
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(VALUE1)) eq 1)
.   compute STR$3 = STR$3 + pack(gettxt(VALUE1))
. else
.   compute STR$3 = STR$3 + ""
. endif
end subprocedure
|
subprocedure GET_VALUE2 |<9>
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(VALUE2)) eq 1)
.   compute STR$3 = STR$3 + pack(gettxt(VALUE2)) |<9>
. else
.   compute STR$3 = STR$3 + ""                   |<9>
. endif
end subprocedure
|
subprocedure GET_ANDOR1 |<6>
. compute STR$3 = STR$3 + ','
. ifthen (exists(gettxt(ANDOR1)) EQ 1)
.   compute STR$3 = STR$3+gettxt(ANDOR1)
. else
.   compute STR$3 = STR$3+'And'
. endif
end subprocedure
end program
|}
END PROCEDURE
