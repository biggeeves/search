PROCEDURE      DIALOGS.JOURNAL_READ:T  (157471,50058)  |Last amended Dec 04, 2013,13:54:18
|| Generated by DP - don't edit anything outside |{...|}

|{ Header
| Creator:   Greg Neils
| Created:   10/20/2008
| Reason:    I need to stuff in the journal and I need to see it now.
| Modified:  12/23/2008. Jan 2009.  Added Journal Row to make it easier to read.  GN
|             04/21/2011 Added CIR
c print back noremarks
|
program
. string  * 100  TESTGLOB   | Does that global exist?
. integer *   1  DUMB_N#    | Cycle thru globals
. string  * 300  USER_FOL   | What is the output folder for the user
c sets the output folder to either a unique persons sign in and DB or there username
c window clear
| set the output folder, and create it if necessary
| add the username to the path
. USER_FOL = dsn('PREFIX') + 'USERS\'
. if (fileis(USER_FOL) eq 0) CHK_DIR = makedir(USER_FOL) | NOT A DIRECTORY OR A FILE
. USER_FOL = USER_FOL + sglobal('USERA')
. if (fileis(USER_FOL) eq 0) CHK_DIR = makedir(USER_FOL) | NOT A DIRECTORY OR A FILE
|
| Define output Folders.  Add Username if possible to the path.
. execute dbms ["attribute seach_html filename='" + dsn('prefix')+ "USERS\Journal"+getenv('username')+".html'"]
. execute dbms ["attribute seach_pql filename='" + dsn('prefix')+ "USERS\JournalRead"+getenv('username')+".pql'"]
. execute dbms ["attribute search_wait filename='" + dsn('prefix')+ "USERS\JournalFinished"+getenv('username')+".pql'"]
. for DUMB_N# = 1,system(53)
.   TESTGLOB = pack(globname(DUMB_N#))
.   ifthen (TESTGLOB = 'USERA')
.     execute dbms ["attribute seach_html filename='" + dsn('prefix')+ "USERS\" + sglobal('USERA') + "\Journal.html'"]
.     execute dbms ["attribute seach_pql filename='" + dsn('prefix')+ "USERS\" + sglobal('USERA') + "\JournalRead.pql'"]
.     execute dbms ["attribute search_wait filename='" + dsn('prefix')+ "USERS\" + sglobal('USERA') + "\JournalFinished.pql'"]
.     exit for
.   endif
. end for
write 'html:  ' [dsn('seach_html')]
write 'pql:   ' [dsn('seach_pql')]
|
end program
|
call SERACH.INCLUDES.ALL_RECS
|
call SYSPROC.TOOLS.HTMLCODE  |sets html globals
GCOMPUTE comment = '. '
|
|
program | crwarn
|}

integer*2 m_id, m_arg1, m_arg2

integer*1 IDSTATIC; preset IDSTATIC (-1)
integer*1 IDCLOSE ; preset IDCLOSE  ( 0)
integer*1 KEY0                            ; preset KEY0                             (1 )
integer*1 KEY0L                           ; preset KEY0L                            (2 )
integer*1 KEY1                            ; preset KEY1                             (3 )
integer*1 KEY1L                           ; preset KEY1L                            (4 )
integer*1 KEY2                            ; preset KEY2                             (5 )
integer*1 KEY2L                           ; preset KEY2L                            (6 )
integer*1 KEY3                            ; preset KEY3                             (7 )
integer*1 KEY3L                           ; preset KEY3L                            (8 )
integer*1 KEY4                            ; preset KEY4                             (9 )
integer*1 KEY4L                           ; preset KEY4L                            (10 )
integer*1 B_PICKKEYS                      ; preset B_PICKKEYS                       (11 )
integer*1 FINDSUBB                        ; preset FINDSUBB                         (12 )
integer*1 FORML                           ; preset FORML                            (13 )
integer*1 FORMS                           ; preset FORMS                            (14 )
integer*1 BUT_JOUNAL                      ; preset BUT_JOUNAL                       (15 )
integer*1 ID_00004                        ; preset ID_00004                         (16 )
integer*1 JOURN_FILE                      ; preset JOURN_FILE                       (17 )
integer*1 JOURN_FIND                      ; preset JOURN_FIND                       (18 )
integer*1 CHK_ALL_RECS                    ; preset CHK_ALL_RECS                     (19 )
integer*1 JOURN_NEW                       ; preset JOURN_NEW                        (20 )
integer*1 JOURN_BEFORE                    ; preset JOURN_BEFORE                     (21 )
integer*1 JOURN_AFTER                     ; preset JOURN_AFTER                      (22 )
integer*1 JOURN_DEL                       ; preset JOURN_DEL                        (23 )
integer*1 JOURN_ALL                       ; preset JOURN_ALL                        (24 )
integer*1 JOURN_KEYS                      ; preset JOURN_KEYS                       (25 )
integer*1 JOURN_DATE                      ; preset JOURN_DATE                       (26 )
integer*1 JOURN_TIME                      ; preset JOURN_TIME                       (27 )
integer*1 JOURN_LEVEL                     ; preset JOURN_LEVEL                      (28 )
integer*1 JOURN_REC                       ; preset JOURN_REC                        (29 )
integer*1 JOURN_TYPE                      ; preset JOURN_TYPE                       (30 )
integer*1 JOURN_USER                      ; preset JOURN_USER                       (31 )
integer*1 ID_00006                        ; preset ID_00006                         (32 )
integer*1 ID_00007                        ; preset ID_00007                         (33 )
integer*1 ID_00008                        ; preset ID_00008                         (34 )
integer*1 ID_00009                        ; preset ID_00009                         (35 )
integer*1 OUTPUT_LOC                      ; preset OUTPUT_LOC                       (36 )
integer*1 ID_00010                        ; preset ID_00010                         (37 )
integer*1 ID_00017                        ; preset ID_00017                         (38 )
integer*1 ID_00018                        ; preset ID_00018                         (39 )
integer*1 VAR_LIST                        ; preset VAR_LIST                         (40 )
integer*1 CLEAR_SEL_BUT                   ; preset CLEAR_SEL_BUT                    (41 )
integer*1 TEMPEXIT                        ; preset TEMPEXIT                         (42 )
integer*1 VARIABLESL                      ; preset VARIABLESL                       (43 )
integer*1 OPTIONALL                       ; preset OPTIONALL                        (44 )
integer*1 JOURN_SCHEMA                    ; preset JOURN_SCHEMA                     (45 )

|{ Prologue
|}

dialog "Database Main Menu"

|{ Controls
postype 1
edit     KEY0                            ,  30,       22, 110, 0, 0
label    KEY0L                           ,  44,       22, 110, "CASE ID"
edit     KEY1                            ,  59,       22, 110, 0, 0
label    KEY1L                           ,  73,       22, 114, ""
edit     KEY2                            ,  84,       22, 110, 0, 0
label    KEY2L                           ,  98,       22, 110, ""
edit     KEY3                            , 109,       22, 110, 0, 0
label    KEY3L                           , 123,       22, 110, ""
edit     KEY4                            , 134,       22, 110, 0, 0
label    KEY4L                           , 148,       22, 110, ""
button   B_PICKKEYS                      , 307,      290,  63, 0, "Pick Keys"
button   FINDSUBB                        , 349,      462,  54, 1, ""
label    FORML                           ,  19,      154, 124, "Forms"
list     FORMS                           ,  30, 132, 154, 254, 0
line     IDSTATIC                        ,   0, 370,  12, 490
label    idstatic                        , 358,       17,  16, "v3"
button   BUT_JOUNAL                      , 326,       80, 158, 0, "Read Journal"
label    ID_00004                        , 234,       62,  76, "3. Report Options"
combo    JOURN_FILE                      , 188,       92, 308
button   JOURN_FIND                      , 188,      402,  21, 0, ">>"
check    CHK_ALL_RECS                    , 211,      140, 136, "Include  ALL  records types"
check    JOURN_NEW                       , 245,      147,  88, "New Recs"
check    JOURN_BEFORE                    , 257,      147,  88, "Before modify"
check    JOURN_AFTER                     , 269,      147,  88, "After modify"
check    JOURN_DEL                       , 281,      147,  88, "Deleted"
radio    JOURN_ALL                       , 309,      140,  53, "Everything"
radio    JOURN_KEYS                      , 309,      201,  88, "Selected keys above"
check    JOURN_DATE                      , 245,      261,  76, "Date modified"
check    JOURN_TIME                      , 257,      261,  76, "Time modified"
check    JOURN_LEVEL                     , 269,      261,  76, "Journal Level"
check    JOURN_REC                       , 245,      345,  88, "Record Name"
check    JOURN_TYPE                      , 257,      345,  88, "Type of update"
check    JOURN_USER                      , 269,      345,  88, "User Name"
label    ID_00006                        , 234,      253,  40, "Show:"
label    ID_00007                        , 234,      140,  40, "Select:"
label    ID_00008                        , 309,       62,  64, "4. Select"
label    ID_00009                        , 346,       17, 310, "WARNING:  Journal file should NOT be the current journal for the database"
label    OUTPUT_LOC                      , 358,       36, 400, "Changes"
label    ID_00010                        , 190,       62,  29, "1. File:"
label    ID_00017                        , 212,       62,  76, "2. Record Types"
label    ID_00018                        , 329,       62,  13, "5."
list     VAR_LIST                        ,  30, 132, 416,  80, 2
button   CLEAR_SEL_BUT                   , 164,      464,  28, 0, "Clear"
button   TEMPEXIT                        ,   0,      473,  28, 0, "exit"
label    VARIABLESL                      ,  19,      418,  64, "Variables"
label    OPTIONALL                       ,  19,       17,  40, "Optional"
check    JOURN_SCHEMA                    , 293,      147,  88, "Schema updates"
|}

initial
|{ Attribs
|< BUT_JOUNAL
. SET ITEM FONT BUT_JOUNAL,1,0,0, 0,""
|>
|< ID_00004
. SET ITEM FONT ID_00004,1,0,0, 0,""
|>
|< ID_00006
. SET ITEM FONT ID_00006,1,0,0, 0,""
|>
|< ID_00007
. SET ITEM FONT ID_00007,1,0,0, 0,""
|>
|< ID_00008
. SET ITEM FONT ID_00008,1,0,0, 0,""
|>
|< ID_00009
. SET ITEM FONT ID_00009,1,0,0, 0,""
|>
|< ID_00010
. SET ITEM FONT ID_00010,1,0,0, 0,""
|>
|< ID_00017
. SET ITEM FONT ID_00017,1,0,0, 0,""
|>
|< ID_00018
. SET ITEM FONT ID_00018,1,0,0, 0,""
|>

|}
|{ Init
| Declare variables
| Case
. string  *   20   NPFONT      | Font type for lists
. string  *   20   P_FONT      | Font type for lables
. integer *    1   NO YES CANCEL   | No=0 Yes=1
. string  *   32   CASE_$V     | CASE_A(getpos(SUBJECTS))
. string  *   32   CASE_$N     | Variable name of case, varname(0, 1)
. integer *    1   VTYPE_#     | What variable type is it
. integer *    2   STAT        | Status of the open file (for reading cases)
. string  *   32   SHOW_$      | String while readin thru caselist file
. integer *    1   EXIT__#     | Returning value from DVPainter
. integer *    1   BOLD N_BOLD ITALIC N_ITALIC UNDERL N_UNDERL SMALL LARGE  |Fonts specifications
. integer *    1   OURKEY#     | Which KEY is it in our terminology (ie we ignoring the fact that CASEID is KEY#1)
. integer *    1   VIAKEY#     | helps construct the VIA for case processing
. integer *    1   KEY#T       | Generic Type of Key vtype(REC_#, keyname(REC_#, KEY#))
. integer *    1   KEY#1T KEY#2T KEY#3T KEY#4T KEY#5T KEY#6T KEY#7T KEY#8T | Key Specific Type of Key vtype(REC_#, keyname(REC_#, KEY#))
. integer *    1   KEY#C       | How many keys a record has nkeys(REC_#)
. integer *    2   KEYMIN      | The minimum range of the key, if there is one
. integer *    2   KEYMAX      | The maximum range of the key, if there is one
. string  *   32   KEY$ KEY$1 KEY$2 KEY$3 KEY$4 KEY$5 KEY$6 KEY$7 KEY$8 KEY$N KEY$V   |Keys
. integer *    1   D_ITEM_#    | Very Tricky.  This contains the number of the DIALOG ITEM you want to append.  ie which Key display
. integer *    2   LAB_CNT     | number of labels for key
. integer *    1   REC_#       | Record #
. string  *   32   REC_$       | Constructing SCRN# for DVPainter
. string  *   32   DVPMEM$N    | Full call to the DVPainter Screen
. integer *    1   VALID_#     | Cycle thru items with value lables, VALID_# etc.
. integer *    2   POS         | abs(srst(KEY$V, ' '))  I dont quite get this one yet
. integer *    2   POS0        | Item user selected
. integer *    1   MEM_O       |
. integer *    1   PROCEED
. date DATE#V ('MMiDDiYYYY')   |Getting the right format for a Date Key
. time TIME#V ('HHiMMiSS')     |Getting the right format for a Time Key
|
. string  *   60   SCR$N       | Passed to Generic Screens.  It is the Recname.  Not sure why.
. string  *   32   SCRMEM$N    | String that calls Generic screens
. string  *   32   MODMEM$N    | String that calls Customized screens
. integer *    1   RESVAR      | Do you want to procede?  Yes NO or Cancel
| List of Forms information
. string  *   40   DOC$        | Something to do with the display length of a record type name
. string  *   45   RECNM$      | Record name padded to the correct length
. string  *  300   MONKEYLINE  | What a great name... The PQL text you want to write to the PQL program
. string  *  300   FILEFILT    | What types of files do you want to dispaly
. STRING  *  300   FILE        | What file did the use choose?
. string  *  120   FORMNAME    | Recname and 1st line of rec doc.
. string  *  100   PASSKEY1E
                   PASSKEY2E
                   PASSKEY3E
                   PASSKEY4E   | Passing the key information from the pick keys dialog
. integer *    1   DUMB_N#     | smalll dumb number.  user whenever
. integer *    2   MAXRECVARS  | Maximun number of columns to add
. check item JOURN_NEW
. check item JOURN_BEFORE
. check item JOURN_AFTER
. check item JOURN_DEL
. check item JOURN_TYPE
. check item JOURN_REC
. check item JOURN_USER
. check item JOURN_ALL
. check item JOURN_DATE
. check item JOURN_TIME
. check item CHK_ALL_RECS
. FILEFILT = 'Sir Journal (*.sr5)|*.sr5|'
. MEM_O = 4
. set NO  (0)
. set YES (1)
. CASE_$N    = varname(0, 1)
| Dialog items
. set dialog title dbname(0)
. set N_BOLD N_ITALIC N_UNDERL (0)
. set BOLD ITALIC UNDERL SMALL (1)
. set LARGE (3)
. set NPFONT ('lucida console')
. set P_FONT ('arial')
. set item font KEY0    ,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
. set item font FORMS   ,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
. set item font VAR_LIST,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
. set item font FORML   ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. set item font FORML   ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. set item font KEY1L   ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. set item font KEY2L   ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. set item font KEY3L   ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. set item font VARIABLESL ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. set item font OPTIONALL  ,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
. append item JOURN_FILE, dsn('SIR015')
| Load the dialog lists
. execute subprocedure LOADFORMS | Note that LOADFORM must come first, because LOADKEYS is called by LOADCASE and LOADKEYS needs to check the FORM to load the proper NUMber of keys.
. execute subprocedure SHOW_KEYS
. execute subprocedure VAR_LIST_APPEND
. focus item KEY0
. hide item FINDSUBB
. set item OUTPUT_LOC, 'Output: ' +dsn('seach_html')
. set MAXRECVARS (0)
. for nrecs = 1, nrecs(0)
.   if (nvars(nrecs) > MAXRECVARS) MAXRECVARS = nvars(nrecs)
. end for

. SCR$N = gettxt(FORMS)
. ifthen (abs(srst(gettxt(FORMS),' ')) gt 0)    | 3.
.   REC_#  = recnum(trimlr(sbst(gettxt(FORMS),1,abs(srst(gettxt(FORMS),' ')))))
. else
.   REC_#  = recnum(trimlr(gettxt(FORMS)))
. endif
. KEY#C  = nkeys(REC_#)              | Because the CASEID is always FIRST ONE.
. execute subprocedure VAR_LIST_APPEND
. execute subprocedure SHOW_KEYS
|}
end initial

message ALL m_id, m_arg1, m_arg2

|{ Message
|}

ifthen (m_id eq B_PICKKEYS )
|< B_PICKKEYS
execute subprocedure PICKKEY
set item KEY1, PASSKEY1E
set item KEY2, PASSKEY2E
set item KEY3, PASSKEY3E
set item KEY4, PASSKEY4E
|>
next message
endif

ifthen (m_id eq FORMS )
|< FORMS
. SCR$N = gettxt(FORMS)
. ifthen (abs(srst(gettxt(FORMS),' ')) gt 0)    | 3.
.   REC_#  = recnum(trimlr(sbst(gettxt(FORMS),1,abs(srst(gettxt(FORMS),' ')))))
. else
.   REC_#  = recnum(trimlr(gettxt(FORMS)))
. endif
. KEY#C  = nkeys(REC_#)              | Because the CASEID is always FIRST ONE.
. execute subprocedure VAR_LIST_APPEND
. execute subprocedure SHOW_KEYS
|>
next message
endif

ifthen (m_id eq BUT_JOUNAL )
|< BUT_JOUNAL

. DUMB_N# = delfile(dsn("seach_pql"))
. ifnot(DUMB_N# EQ 0) WRITE 'PREVIOUS PROGRAM WAS NOT DELETED.  DOUBLE CHECK PROGRAM FILE!' DUMB_N#
. DUMB_N# = delfile(dsn("seach_html"))
. ifnot(DUMB_N# EQ 0) WRITE 'PREVIOUS RESULTS WERE NOT DELETED.  DOUBLE CHECK HTML FILE!' DUMB_N#

. ifthen (abs(srst(gettxt(FORMS),' ')) gt 0)    | 3.
.   REC_#  = recnum(trimlr(sbst(gettxt(FORMS),1,abs(srst(gettxt(FORMS),' ')))))
. else
.   REC_#  = recnum(trimlr(gettxt(FORMS)))
. endif
. FORMNAME = gettxt(FORMS)
. open search_wait   /write  | Create this file.  When the program finishes, it deletes this file.
. close search_wait

. open seach_pql   /write lrecl=600
. write(seach_pql) 'retrieval noautocase |crwarn'
. write(seach_pql) 'integer *   1  KEYS         | Cycle through the keys in a record'
. write(seach_pql) 'integer *   1  KEY_YN       | Is a key'
. write(seach_pql) 'string  *  45  TXTVAR1      | 1st Variable name as text'
. write(seach_pql) 'integer *   1  A_COLOR      | 1= no color 2=color'
. write(seach_pql) 'string  *  30  HTML_CLR     | #EAEAEA  OR #FFFFFF'
. write(seach_pql) 'integer *   1  DUMB_N#      | Helps open HTML browser'
. write(seach_pql) 'string  *  50  START_TD     | the starter line for the HTML column'
. write(seach_pql) 'string  *  20  BOLD_NVAR    | HTML row color'
. write(seach_pql) 'integer *   2  WHO_WAS_#    | The array number '
. write(seach_pql) 'date           array WHO_WAS_IN_DATE  (1,1000) (mmiddiyyyy)  | Array for the date'
. write(seach_pql) 'time           array WHO_WAS_IN_STIME (1,1000) (hhimm) | Array for start time'
. write(seach_pql) 'time           array WHO_WAS_IN_ETIME (1,1000) (hhimm) | Array for end time'
. write(seach_pql) 'string  *  32  array WHO_WAS_IN_USER  (1,1000) | Array for username'
. write(seach_pql) 'integer *   1  SHOW_VALUE   | 0=No, not wanted or didnt not match.   1=Yes, Key, or matched value of user selection'
. ifthen (getichk(CHK_ALL_RECS) eq 0) | CAN NOT DO this across all record types.
.   ifthen (getnsel(VAR_LIST) ne 0)
.     write(seach_pql) 'string  *  32  array SHOW_THIS_VAR    (' [getnsel(VAR_LIST)]  ' )   | Array for selected variables'
.   endif
. endif
. write(seach_pql) 'integer *   1  JOURN_SELECT | Select this journal entry '
. write(seach_pql) 'integer *   1  JTYPE | The type of record update'
. write(seach_pql) 'string  *  10  FORMAT_DATE  | Date format' | to make this easier to program
. write(seach_pql) 'string  *   5  FORMAT_TIME  | Time format' | to make this easier to program
. write(seach_pql) 'integer *   4  IOSTAT_#     | Did we get the HTML file successfully' | to make this easier to program
. write(seach_pql) 'integer *   4  ROW_#        | Where are we in the journal' | to make this easier to program

. write(seach_pql) 'value labels  JTYPE (1) "New record"'
. write(seach_pql) '                    (2) "Before update"'
. write(seach_pql) '                    (3) "After update"'
. write(seach_pql) '                    (4) "Record deleted"'
. write(seach_pql) '                    (-1)"Journal Data Header"'
. write(seach_pql) '                    (-2)"Unload Schema Header"'
. write(seach_pql) '                    (-3)"Unload Data Header"'
. write(seach_pql) '                    (-4)"Journal Schema Header"'
. write(seach_pql) '                    (-5)"User Header"'
. write(seach_pql) 'value labels  IOSTAT_#  (-5) "File locked (in use)"'
. write(seach_pql) '                        (-6) "File not found"'
. write(seach_pql) '                        (-8) "Access problem"'
. write(seach_pql) '                        (-9) "Miscellaneous problems"'
. write(seach_pql) 'set A_COLOR (0)'
. write(seach_pql) 'set FORMAT_DATE ("mm/dd/yyyy")'
. write(seach_pql) 'set FORMAT_TIME ("HH:MM:SS")'
. write(seach_pql) 'set WHO_WAS_IN_USER * ("0")'
. write(seach_pql) 'set ROW_# (0)'  | What row in the journal file are we on.

. write(seach_pql) '|  NCASEID_#  can not be defined as it could be anything so it defines on the fly'
. ifthen (getichk(CHK_ALL_RECS) eq 0) | CAN NOT DO this across all record types.
.   ifthen (getnsel(VAR_LIST) gt 0)
.     for N = 1, getnsel(VAR_LIST)
.       ifthen (abs(srst(gettxt(VAR_LIST),' ')) gt 0)   | Get the record number
.         Vic = sbst(getitxt(VAR_LIST,getmsel(VAR_LIST,N)) ,1, abs(srst(getitxt(VAR_LIST,getmsel(VAR_LIST,N)),' '))-1)
.       else
.         Vic = getitxt(VAR_LIST,getmsel(VAR_LIST,N))
.       endif
.       MONKEYLINE = '. SHOW_THIS_VAR(' + format(N) + ') = "' + VIC + '"'
.       write(seach_pql) MONKEYLINE
.     end for
.   endif
. endif
. ifthen (dbtype(0) eq 1)
.   write(seach_pql) 'process cases count = 1'
.   write(seach_pql) 'end cases'
. endif
. write(seach_pql) 'open   seach_html   /write lrecl=600 IOSTAT=IOSTAT_#'
. write(seach_pql) 'ifthen (IOSTAT_# ne 0) '
. write(seach_pql) '.  display infobox "Could not open HTML output file: IOSTAT " + vallab(IOSTAT_#)'
. write(seach_pql) '.  DUMB_N# = delfile(dsn("search_wait"))'
. write(seach_pql) '.  close (seach_html) DELETE'
. write(seach_pql) '.  exit retrieval'
. write(seach_pql) 'endif'


. compute MONKEYLINE ='<' + CHAR(33) + 'DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">'
. write(seach_pql) 'write (seach_html) ' "'" MONKEYLINE "'"
. write(seach_pql) 'write (seach_html) "<html>"'
. write(seach_pql) 'write (seach_html) "<head>"'
. write(seach_pql) 'write (seach_html) "<title>"'
. write(seach_pql) 'write (seach_html) "PROCESSED JOURNAL"'
. write(seach_pql) 'write (seach_html) "</title>"'
. write(seach_pql) 'write (seach_html) "</head>"'
. write(seach_pql) 'write (seach_html) "<body>"'
. MONKEYLINE = 'write (seach_html) "<table border=1 width=' + "'" + '100%' + "'" + '><tr><td>"'
. write(seach_pql) MONKEYLINE
. MONKEYLINE = 'write (seach_html) "  <table border=0 bgcolor=' + "'" + '#FFFFCC' + "'" + '>"'
. write(seach_pql) MONKEYLINE
. MONKEYLINE = 'write (seach_html) "    <tr><td><p><big>JOURNAL Table generated on '
. MONKEYLINE = MONKEYLINE + datec(today(0),"MM/DD/YY") + ' at  ' + timec(now(0),"HH:MM:SS") + ' by the D.C.C.</big></p></td></tr>"'
. write(seach_pql) MONKEYLINE
. ifthen (getichk(CHK_ALL_RECS) eq 1)   | Do all records
.   MONKEYLINE = 'write (seach_html) "    <tr><td><p><b><big>All Record Types</big></b></p></td></tr>"'
.   write(seach_pql) MONKEYLINE
. else
.   MONKEYLINE = 'write (seach_html) "    <tr><td><p><b><big>' + FORMNAME +'</big></b></p></td></tr>"'
.   write(seach_pql) MONKEYLINE
. endif
. MONKEYLINE = 'write (seach_html) "    <tr><td><hr></td></tr>"'
. write(seach_pql) MONKEYLINE
. MONKEYLINE = 'write (seach_html) "  </table> "'
. write(seach_pql) MONKEYLINE
. MONKEYLINE = 'write (seach_html) "  <table border=1 CELLPADDING=10 CELLSPACING=0>"'
. write(seach_pql) MONKEYLINE
. MONKEYLINE = 'write (seach_html) "    <tr bgcolor=' + "'" + '#C4D4FC'+ "'"+ '>"'
. write(seach_pql) MONKEYLINE


. write(seach_pql) 'write (seach_html) "   <td>JRow</td>"'  | adding the row might help when communicating with people
. if (getichk(JOURN_DATE)  eq 1) write(seach_pql) 'write (seach_html) "    <td>Date</td>"'
. if (getichk(JOURN_TIME)  eq 1) write(seach_pql) 'write (seach_html) "    <td>Time</td>"'
. if (getichk(JOURN_LEVEL) eq 1) write(seach_pql) 'write (seach_html) "    <td>Level</td>"'
. if (getichk(JOURN_REC)   eq 1) write(seach_pql) 'write (seach_html) "    <td>Rec #</td>"'
. if (getichk(JOURN_TYPE)  eq 1) write(seach_pql) 'write (seach_html) "    <td>Type</td>"'
. if (getichk(JOURN_USER)  eq 1) write(seach_pql) 'write (seach_html) "    <td>User</td>"'

. ifthen (getichk(CHK_ALL_RECS) eq 1)   | Do all records
.   START_REC# = 1
.   END_REC#   = NRECS(0)
. else
.   START_REC# = REC_#
.   END_REC#   = REC_#
. endif

. ifthen (getichk(CHK_ALL_RECS) eq 1)   | Do all records
.   MONKEYLINE = 'write (seach_html) "    <td bgcolor=' +"'" + '#FFFFFF' + "'" + '><strong>' + CASE_$N + '</strong></td>"'
.   write(seach_pql)   'for XVARS = 1,' MAXRECVARS
.   write(seach_pql)   '. write (seach_html) "<td>Variable #:  " XVARS  "</td>"'
.   write(seach_pql)   'end for'
.   write(seach_pql)   'write (seach_html) "    </tr>"'
. else
.   MONKEYLINE = '. write (seach_html) "    <td bgcolor=' +"'" + '#FFFFFF' + "'" + '><strong>' + CASE_$N + '</strong></td>"'
.   write(seach_pql) MONKEYLINE
.   write(seach_pql)   'for XVARS = 1,nvars(' REC_# ')'
.   write(seach_pql)   '. KEY_YN = 0'
.   write(seach_pql)   '. for KEYS = 1,nkeys(' REC_# ') + 1 | look for Key variables... If KEY BOLD font.'
.   write(seach_pql)   '.   if (pack(varname(' REC_# ',XVARS)) eq pack(keyname(' REC_# ',KEYS))) KEY_YN = 1'
.   write(seach_pql)   '. end for'
.   write(seach_pql)   '. if then (KEY_YN eq 1)'
.   MONKEYLINE = '.   write (seach_html) "<td bgcolor=' +"'" + '#FFFFFF' + "'" + '><strong>" [varname(' + format(REC_#) +',XVARS)] "</strong></td>"'
.   write(seach_pql) MONKEYLINE
.   write(seach_pql)   '. else'
|   only output the variables the user wanted.  find which ones these are.
.   ifthen (getnsel(VAR_LIST) eq 0) | wanted all (none selected)
.     write(seach_pql) '.   write (seach_html) "<td> " [varname(' REC_# ',XVARS)] "</td>"'
.   else
.     write(seach_pql) '.   for N = 1, ' [getnsel(VAR_LIST)]
.     write(seach_pql) '.     ifthen( SHOW_THIS_VAR(N)= trim(varname(' REC_# ',XVARS)))'
.     write(seach_pql) '.       write (seach_html) "<td> " [varname(' REC_# ',XVARS)] "</td>"'
.     write(seach_pql) '.       exit for'
.     write(seach_pql) '.     endif'
.     write(seach_pql) '.   end for'
.   endif
.   write(seach_pql)   '. end if'
.   write(seach_pql)   'end for'
.   write(seach_pql)   'write (seach_html) "    </tr>"'
. endif

. write(seach_pql) 'PROCESS JOURNAL'
. MONKEYLINE = ' filename = "' + gettxt(JOURN_FILE) + '"'
. write(seach_pql) MONKEYLINE
. write(seach_pql) '    DATE     = JSTARTDT'
. write(seach_pql) '    TIME     = JSTARTTM'
. write(seach_pql) '    LEVEL    = JLEVEL'
. write(seach_pql) '    RECORD   = JRECORD'
. write(seach_pql) '    TYPE     = JTYPE'
. write(seach_pql) '    USER     = JUSER'
. write(seach_pql) '    ENDDATE  = JENDDT'
. write(seach_pql) '    ENDTIME  = JENDTM'
|   GET CASE ID
. write(seach_pql) '. WHO_WAS_# = 0'  | Starts the array number
. write(seach_pql) '. START_TD ="<tr><td>"'





. write(seach_pql) '. JOURNAL RECORD IS 0'
ifthen (dbtype(0) eq 1)
. write(seach_pql) '.   NCASEID_# = ' CASE_$N | GET THE CASEID
endif
. write(seach_pql) '.   WHO_WAS_# = 0'  | THIS IS STILL IN DEVELOPMENT.  THE ARRARY SORT NEEDS A LOT OF ATTENTION BECAUSE IT IS 2D AND NEEDS A FUNKY SORT FOR 2D SORTING.
. write(seach_pql) '.   ROW_# = ROW_# + 1'  | What row in the journal file are we on.
. execute subprocedure SELECT_JOURNAL_ITEMS  | show the items the user selected from the journal
. ifthen (getichk(CHK_ALL_RECS) eq 0)
.   MONKEYLINE = '.     if (JTYPE eq 2) get vars NVAR_C1 to NVAR_C' + format(nvars(0)) + ' = ' + trim(varname(0,1)) + ' to ' + trim(varname(0,(nvars(0))))
.   write(seach_pql) MONKEYLINE
. endif
ifthen (dbtype(0) eq 1)
. write(seach_pql) '.     write (seach_html) "<td>" NCASEID_# "</td>"'
endif
. ifthen (getichk(CHK_ALL_RECS) eq 0)   | CAN NOT DO this across all record types.  We... I could, but I think it is too much.
.   write(seach_pql) '.     WHO_WAS_# = WHO_WAS_# + 1'
.   write(seach_pql) '.     WHO_WAS_IN_DATE (1,WHO_WAS_#) = datec(JSTARTDT,FORMAT_DATE)'
.   write(seach_pql) '.     WHO_WAS_IN_STIME(1,WHO_WAS_#) = timec(JSTARTTM,FORMAT_TIME)'
.   write(seach_pql) '.     WHO_WAS_IN_ETIME(1,WHO_WAS_#) = timec(JRETURN_ENDTIME,FORMAT_TIME)'
.   write(seach_pql) '.     WHO_WAS_IN_USER (1,WHO_WAS_#) = JUSER'
. endif
. write(seach_pql) '.     for XVARS = 1,nvars(0)'
. write(seach_pql) '.       TXTVAR1 = varname(0,XVARS)'
. write(seach_pql) '.       BOLD_NVAR = "" '  | You always need a value for BOLD_VAR
|     Bold the different changes
. write(seach_pql)     '.       SHOW_VALUE = 0'
|   only output the variables the user wanted.  find which ones these are.
. ifthen (getichk(CHK_ALL_RECS) eq 1)   | Show all values
.   write(seach_pql)   '.        SHOW_VALUE = 1'
. elseif (getichk(CHK_ALL_RECS) eq 0)
.   ifthen (getnsel(VAR_LIST) eq 0) | wanted all (none selected)
.     write(seach_pql) '.        SHOW_VALUE = 1'
.   else
.     write(seach_pql) '.        for N = 1, ' [getnsel(VAR_LIST)]
.     write(seach_pql) '.          ifthen( SHOW_THIS_VAR(N)= trim(varname(0,XVARS)))'
.     write(seach_pql) '.             SHOW_VALUE = 1'
.     write(seach_pql) '.            exit for'
.     write(seach_pql) '.          endif'
.     write(seach_pql) '.        end for'
.   endif
. endif
|     Compare Before and after results.
. ifthen (getichk(CHK_ALL_RECS) eq 0)   | CAN NOT DO this across all record types.  We... I could, but I think it is too much.
.   write(seach_pql) '.       ifthen (JTYPE eq 3)'
.   write(seach_pql) '.         if (varget("NVAR_C" + format(XVARS)) ne varget(TXTVAR1) ) BOLD_NVAR = "<STRONG>" '
.   write(seach_pql) '.       endif'
. endif
| Show the values
. write(seach_pql)   '.       if then (exists(varget(TXTVAR1)) eq 0) |it MIGHT be a missing value.'
. write(seach_pql)   '.         evaluate MISVAL = "misnum(" + trim(TXTVAR1) + ")"'
. write(seach_pql)   '.         if then (exists(miss(0,TXTVAR1,MISVAL)) eq 1)'
. write(seach_pql)   '.           write (seach_html) "<td>" [miss(0,TXTVAR1,MISVAL)] "&nbsp;</td>"'
. write(seach_pql)   '.         else'
. write(seach_pql)   '.           write (seach_html) "<td>&nbsp;</td>"'
. write(seach_pql)   '.         end if'
. write(seach_pql)   '.       else |NOT A MISSING VALUE'
. write(seach_pql)   '.         write (seach_html) "<td>" BOLD_NVAR [trim(varget(TXTVAR1))] "</td>"'
. write(seach_pql)   '.       end if'
. write(seach_pql)   '.     end for'
. write(seach_pql)   '.     write (seach_html) "    </tr>"'

. write(seach_pql)   '. END JOURNAL RECORD IS'


. for NRECS_# = START_REC#, END_REC#
.   ifNOT (len(recname(NRECS_#)) gt 0) NEXT FOR

.   write(seach_pql) '. JOURNAL RECORD IS ' NRECS_#
ifthen (dbtype(0) eq 1)
.   write(seach_pql) '.   NCASEID_# = ' CASE_$N | GET THE CASEID
endif
.   write(seach_pql) '.   WHO_WAS_# = 0'  | THIS IS STILL IN DEVELOPMENT.  THE ARRARY SORT NEEDS A LOT OF ATTENTION BECAUSE IT IS 2D AND NEEDS A FUNKY SORT FOR 2D SORTING.
.   write(seach_pql) '. END JOURNAL RECORD IS'

.   write(seach_pql) '. JOURNAL RECORD IS ' NRECS_#
.   write(seach_pql) '.   ROW_# = ROW_# + 1'  | What row in the journal file are we on.

.   if (getichk(JOURN_KEYS) eq 1) execute subprocedure SELECTED_KEYS         | See if the user wanted certain keys

.   execute subprocedure SELECT_JOURNAL_ITEMS  | show the items the user selected from the journal
|
.   ifthen (getichk(CHK_ALL_RECS) eq 0)
.     MONKEYLINE = '.     if (JTYPE eq 2) get vars NVAR_C1 to NVAR_C' + format(nvars(NRECS_#)) + ' = ' + trim(varname(NRECS_#,1)) + ' to ' + trim(varname(NRECS_#,(nvars(NRECS_#))))
.     write(seach_pql) MONKEYLINE
.   endif
ifthen (dbtype(0) eq 1)
.   write(seach_pql) '.     write (seach_html) "<td>" NCASEID_# "</td>"'
endif

.   ifthen (getichk(CHK_ALL_RECS) eq 0)   | CAN NOT DO this across all record types.  We... I could, but I think it is too much.
.     write(seach_pql) '.     WHO_WAS_# = WHO_WAS_# + 1'
.     write(seach_pql) '.     WHO_WAS_IN_DATE (1,WHO_WAS_#) = datec(JSTARTDT,FORMAT_DATE)'
.     write(seach_pql) '.     WHO_WAS_IN_STIME(1,WHO_WAS_#) = timec(JSTARTTM,FORMAT_TIME)'
.     write(seach_pql) '.     WHO_WAS_IN_ETIME(1,WHO_WAS_#) = timec(JRETURN_ENDTIME,FORMAT_TIME)'
.     write(seach_pql) '.     WHO_WAS_IN_USER (1,WHO_WAS_#) = JUSER'
.   endif
.   write(seach_pql) '.     for XVARS = 1,nvars(' NRECS_# ')'
.   write(seach_pql) '.       TXTVAR1 = varname(' NRECS_# ',XVARS)'
.   write(seach_pql) '.       BOLD_NVAR = "" '  | You always need a value for BOLD_VAR
|   Bold the different changes
.   write(seach_pql)     '.       SHOW_VALUE = 0'
.   write(seach_pql)     '.       for KEYS = 1,nkeys(' NRECS_# ') + 1 | look for Key variables... If KEY BOLD font.'
.   write(seach_pql)     '.         if (pack(varname(' NRECS_# ',XVARS)) eq pack(keyname(' NRECS_# ',KEYS))) SHOW_VALUE = 1'
.   write(seach_pql)     '.       end for'
| only output the variables the user wanted.  find which ones these are.
.   ifthen (getichk(CHK_ALL_RECS) eq 1)   | Show all values
.     write(seach_pql)   '.        SHOW_VALUE = 1'
.   elseif (getichk(CHK_ALL_RECS) eq 0)
.     ifthen (getnsel(VAR_LIST) eq 0) | wanted all (none selected)
.       write(seach_pql) '.        SHOW_VALUE = 1'
.     else
.       write(seach_pql) '.        for N = 1, ' [getnsel(VAR_LIST)]
.       write(seach_pql) '.          ifthen( SHOW_THIS_VAR(N)= trim(varname(' NRECS_# ',XVARS)))'
.       write(seach_pql) '.             SHOW_VALUE = 1'
.       write(seach_pql) '.            exit for'
.       write(seach_pql) '.          endif'
.       write(seach_pql) '.        end for'
.     endif
.   endif
|   Throw it out if the user didnt want it and it is not a key value.  DONT waste any more time
.   write(seach_pql)     '.       if (SHOW_VALUE = 0)  NEXT FOR'

|   Compare Before and after results.
.   ifthen (getichk(CHK_ALL_RECS) eq 0)   | CAN NOT DO this across all record types.  We... I could, but I think it is too much.
.     write(seach_pql) '.       ifthen (JTYPE eq 3)'
.     write(seach_pql) '.         if (varget("NVAR_C" + format(XVARS)) ne varget(TXTVAR1) ) BOLD_NVAR = "<STRONG>" '
.     write(seach_pql) '.       endif'
.   endif
|   Show the values
.   write(seach_pql)   '.       if then (exists(varget(TXTVAR1)) eq 0) |it MIGHT be a missing value.'
.   write(seach_pql)   '.         evaluate MISVAL = "misnum(" + trim(TXTVAR1) + ")"'
.   write(seach_pql)   '.         if then (exists(miss(' NRECS_#  ',TXTVAR1,MISVAL)) eq 1)'
.   write(seach_pql)   '.           write (seach_html) "<td>" [miss('  NRECS_# ',TXTVAR1,MISVAL)] "&nbsp;</td>"'
.   write(seach_pql)   '.         else'
.   write(seach_pql)   '.           write (seach_html) "<td>&nbsp;</td>"'
.   write(seach_pql)   '.         end if'
.   write(seach_pql)   '.       else |NOT A MISSING VALUE'
.   write(seach_pql)   '.         write (seach_html) "<td>" BOLD_NVAR [trim(varget(TXTVAR1))] "</td>"'
.   write(seach_pql)   '.       end if'
.   write(seach_pql)   '.     end for'
.   write(seach_pql)   '.     write (seach_html) "</tr>"'

.   write(seach_pql)   '. END JOURNAL RECORD IS'
. end for
. write(seach_pql) 'END PROCESS JOURNAL'

| summary stuff

. ifthen (getichk(CHK_ALL_RECS) eq 0)   | CAN NOT DO this across all record types.  We... I could, but I think it is too much.
.   write(seach_pql) '. SORT WHO_WAS_IN_DATE  by WHO_WAS_IN_STIME'
.   write(seach_pql) '. SORT WHO_WAS_IN_ETIME by WHO_WAS_IN_STIME'
.   write(seach_pql) '. SORT WHO_WAS_IN_USER  by WHO_WAS_IN_STIME'
.   write(seach_pql) '. SORT WHO_WAS_IN_STIME'
.   for NRECS_# = START_REC#, END_REC#
.     ifNOT (len(recname(NRECS_#)) gt 0) NEXT FOR
.     write(seach_pql) '. for NNNN = 1,1000'
.     MONKEYLINE = '.     if (WHO_WAS_IN_USER(1,NNNN) eq "0")  NEXT FOR'
.     write(seach_pql) MONKEYLINE
.     MONKEYLINE = '.     write  [datec(WHO_WAS_IN_DATE(1,NNNN),"mm/dd/yyyy")]'
.     MONKEYLINE = MONKEYLINE + '"  " '  + '[timec(WHO_WAS_IN_STIME(1,NNNN),"hh:mm")]'
.     MONKEYLINE = MONKEYLINE + '" - "'  + '[timec(WHO_WAS_IN_ETIME(1,NNNN),"hh:mm")]'
.     MONKEYLINE = MONKEYLINE + '"  : "' + 'WHO_WAS_IN_USER(1,NNNN)'
.     write(seach_pql) MONKEYLINE
.     write(seach_pql) '. end for'
.   end for
. endif

. write(seach_pql) 'write (seach_html) "  </table>"'
. write(seach_pql) 'write (seach_html) "</td></tr>"'
. write(seach_pql) 'write (seach_html) "</table>"'
. write(seach_pql) 'write (seach_html) "</body>"'
. write(seach_pql) 'write (seach_html) "</html>"'
. write(seach_pql) 'write "Finsihed seach_html, Results HTML file"'
. write(seach_pql) 'close (seach_html)'
. write(seach_pql) 'open  (search_wait) write'
. write(seach_pql) 'write (search_wait) "working on it" '
. write(seach_pql) 'close (search_wait) delete'

. write(seach_pql) 'end retrieval'

. close seach_pql
. wait 1
|
. if (fileis(dsn('seach_pql')) eq 1) execute dbms ['include file "' +dsn('seach_pql') +'"']


. while (fileis(dsn('search_wait')) eq 1)
.   wait 10 | because the program needs time to work.
.   write [timec(now(0),'hh:mm')] ' .... Checking if task is completed'
. end while
|
. wait 1 | because the program needs time to work.
. if (fileis(dsn('seach_html')) eq 1) DUMB_N# = help('file: "'+dsn('seach_html')+'"')
|
|

|>
next message
endif

ifthen (m_id eq JOURN_FIND )
|< JOURN_FIND
. FILE = '\\192.168.53.246\backups\*.sr5'
. display openbox 'Select Journal File',
                  'Sir Journal|*.sr5|',
                  'sr5',
                  1 RESPONSE rc,FILE
. ifthen (rc gt 0)
.   append item JOURN_FILE,FILE
.   set item JOURN_FILE,FILE
. endif
|>
next message
endif

ifthen (m_id eq CHK_ALL_RECS )
|< CHK_ALL_RECS
. ifthen (M_ARG1 eq 1)
.   clear all VAR_LIST
.   disable item VAR_LIST
.   disable item CLEAR_SEL_BUT
. else
.   enable item CLEAR_SEL_BUT
.   enable item VAR_LIST
. endif
|>
next message
endif

ifthen (m_id eq VAR_LIST )
|< VAR_LIST
cif eq 1,2
for N = 1, getnsel(VAR_LIST)
. ifthen (abs(srst(gettxt(VAR_LIST),' ')) gt 0)   | Get the record number
.   Vic = sbst(getitxt(VAR_LIST,getmsel(VAR_LIST,N)) ,1, abs(srst(getitxt(VAR_LIST,getmsel(VAR_LIST,N)),' ')))
. else
.   Vic = getitxt(VAR_LIST,getmsel(VAR_LIST,N))
. endif
end for
cif end
|>
next message
endif

ifthen (m_id eq TEMPEXIT )
|< TEMPEXIT
exit message
|>
next message
endif

if (m_id eq 0) exit message

end message


end dialog
|{ Exit
|}
|{ Footer
subprocedure LOADFORMS
<comment> write 'sub: LOADFORMS'
. ifthen (meminfo('NAVIGATE.LOADFORM:O',1) = MEM_O)
.   execute subroutine NAVIGATE.LOADFORM
. else
.   append item FORMS, 'CIR'
.   for REC_# = 1, nrecs(0)
.     ifthen (len(recname(REC_#)) gt 0)
.       ifthen (len(trimlr(recname(REC_#))) lt 10)
.         RECNM$ = pad(recname(REC_#),' ', 10, 10)
.       else
.         RECNM$ = trimlr(recname(REC_#)) + ' ' | space is very important!  Don't touch.
.       endif
.       DOC$  = ' '
.       ifthen (exists(recdoc(REC_#,1)) = YES)
.         DOC$ = trimlr(replace(recdoc(REC_#,1),char(9),'',5,0,0)) | Get rid of tabs in the DOCUMENT line
.       endif
.       append item FORMS, RECNM$ + DOC$
.     endif
.   end for
. endif
end subprocedure LOADFORMS
|
|
subprocedure HIDEALL
<comment> write 'sub: HIDEALL'
. remove all   KEY1
. hide item    KEY1
. set item     KEY1L,''
. remove all   KEY2
. hide item    KEY2
. set item     KEY2L,''
. remove all   KEY3
. hide item    KEY3
. set item     KEY3L,''
. remove all   KEY4
. hide item    KEY4
. set item     KEY4L,''
end subprocedure HIDEALL
|
|
subprocedure SELECT_JOURNAL_ITEMS
. write(seach_pql)     '.     JOURN_SELECT = 0'
. if (getichk(JOURN_NEW)    eq 1) write(seach_pql) '.     if (JTYPE = 1)  JOURN_SELECT = 1'
. if (getichk(JOURN_BEFORE) eq 1) write(seach_pql) '.     if (JTYPE = 2)  JOURN_SELECT = 1'
. if (getichk(JOURN_AFTER)  eq 1) write(seach_pql) '.     if (JTYPE = 3)  JOURN_SELECT = 1'
. if (getichk(JOURN_DEL)    eq 1) write(seach_pql) '.     if (JTYPE = 4)  JOURN_SELECT = 1'
. if (getichk(JOURN_SCHEMA) eq 1) write(seach_pql) '.     if (JTYPE = -4) JOURN_SELECT = 1'
. write(seach_pql) '.     if (JOURN_SELECT = 0) NEXT PROCESS JOURNAL'
. write(seach_pql) '.     write (seach_html) "<tr><td>" ROW_# "</td>"'
. if (getichk(JOURN_DATE)  eq 1) write(seach_pql)   '.     write (seach_html) "<td>" [datec(JSTARTDT,FORMAT_DATE)] "</td>"'
. if (getichk(JOURN_TIME)  eq 1) write(seach_pql)   '.     write (seach_html) "<td>" [timec(JSTARTTM,FORMAT_TIME)] "</td>"'
. if (getichk(JOURN_LEVEL) eq 1) write(seach_pql)   '.     write (seach_html) "<td>" JLEVEL "</td>"'
. if (getichk(JOURN_REC)   eq 1) write(seach_pql)   '.     write (seach_html) "<td>" JRECORD "<br>" [pack(recname(JRECORD))] "</td>"'
. if (getichk(JOURN_TYPE)  eq 1) write(seach_pql)   '.     write (seach_html) "<td>" [pack(vallab(JTYPE))] "</td>"'
. if (getichk(JOURN_USER)  eq 1) write(seach_pql)   '.     write (seach_html) "<td>"  JUSER "</td>"'
end subprocedure
|
subprocedure PICKKEY
<comment> write 'sub: PICKKEY'
. integer*1 CLOSER   ; CLOSER   =0
. integer*1 CANCEL_X ; CANCEL_X =1
. integer*1 NEWKEY1  ; NEWKEY1  =2
. integer*1 NEWKEY1L ; NEWKEY1L =3
. integer*1 NEWKEY1E ; NEWKEY1E =4
. integer*1 NEWKEY1H ; NEWKEY1H =5
. integer*1 NEWKEY2  ; NEWKEY2  =6
. integer*1 NEWKEY2L ; NEWKEY2L =7
. integer*1 NEWKEY2E ; NEWKEY2E =8
. integer*1 NEWKEY2H ; NEWKEY2H =9
. integer*1 NEWKEY3  ; NEWKEY3  =10
. integer*1 NEWKEY3L ; NEWKEY3L =11
. integer*1 NEWKEY3E ; NEWKEY3E =12
. integer*1 NEWKEY3H ; NEWKEY3H =13
. integer*1 NEWKEY4  ; NEWKEY4  =14
. integer*1 NEWKEY4L ; NEWKEY4L =15
. integer*1 NEWKEY4E ; NEWKEY4E =16
. integer*1 NEWKEY4H ; NEWKEY4H =17
. integer*1 SELECTL  ; SELECTL  =18
. integer*1 B_ADD1   ; B_ADD1   =51
. integer*1 B_ADD2   ; B_ADD2   =52
. integer*1 B_ADD3   ; B_ADD3   =53
. integer*1 B_ADD4   ; B_ADD4   =54
. dialog "Select keys.  "
|   LIST    id      ,row ,   height, col, width ,type
|   LABEL   id      ,row ,           col, width,text
.   postype 1
.   line    IDSTATIC,  0, 370,   0, 490
.   button  CANCEL_X,  5,      430,  40, 1, "Cancel"
.   button  B_ADD1  , 60,       60, 120, 0, "2.  Go to form"
.   button  B_ADD2  , 155,       60, 120, 0, "3.  Go to form"
.   button  B_ADD3  , 250,       60, 120, 0, "4.  Go to form"
.   button  B_ADD4  , 340,       60, 120, 0, "5.  Go to form"
.   label   SELECTL ,   5,      200, 150,    "Or select a value from these choices"
.   label   NEWKEY1L,   5,       50, 120,    "Displays Key Label"
.   edit    NEWKEY1E,  20,       60, 120, 0,0
.   label   NEWKEY1H,  40,       70, 120,    "Displays Help information"
.   list    NEWKEY1 ,  20,  60, 200, 210, 0
.   label   NEWKEY2L, 100,       50, 120,    "Displays Key Label"
.   edit    NEWKEY2E, 115,       60, 120, 0,0
.   label   NEWKEY2H, 135,       70, 120,    "Displays Help information"
.   list    NEWKEY2 , 115,  60, 200, 210, 0
.   label   NEWKEY3L, 195,       50, 120,    "Displays Key Label"
.   edit    NEWKEY3E, 210,       60, 120 , 0,0
.   label   NEWKEY3H, 230,       70, 120,    "Displays Help information"
.   list    NEWKEY3 , 210,  60, 200, 210, 0
.   label   NEWKEY4L, 290,       50, 120,    "Displays Key Label"
.   edit    NEWKEY4E, 305,       60, 120, 0,0
.   label   NEWKEY4H, 325,       70, 120,    "Displays Help information"
.   list    NEWKEY4 , 305,  60, 200, 210, 0
.   initial
.     string  * 200  TXT$
.     integer *   4  HOWMANY#
.     PASSCHCK = 0 | it is funny.  I set this to 0 and then set it later to 1 It works.  It is designed that way.
.     set item font NEWKEY1L,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
.     set item font NEWKEY2L,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
.     set item font NEWKEY3L,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
.     set item font NEWKEY4L,N_BOLD,N_ITALIC,UNDERL  ,LARGE,P_FONT
.     set item font NEWKEY1H,N_BOLD,N_ITALIC,N_UNDERL,0,NPFONT
.     set item font NEWKEY2H,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     set item font NEWKEY3H,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     set item font NEWKEY4H,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     set item font NEWKEY1E,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     set item font NEWKEY2E,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     set item font NEWKEY3E,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     set item font NEWKEY4E,N_BOLD,N_ITALIC,N_UNDERL,SMALL,NPFONT
.     focus item NEWKEY1E
.     ifthen (nkeys(REC_#) = 1)
.       hide item B_ADD2
.       hide item NEWKEY2
.       hide item NEWKEY2L
.       hide item NEWKEY2E
.       hide item NEWKEY2H
.       hide item B_ADD3
.       hide item NEWKEY3
.       hide item NEWKEY3L
.       hide item NEWKEY3E
.       hide item NEWKEY3H
.       hide item B_ADD4
.       hide item NEWKEY4
.       hide item NEWKEY4L
.       hide item NEWKEY4E
.       hide item NEWKEY4H
.     elseif (nkeys(REC_#) = 2)
.       hide item B_ADD1
.       hide item B_ADD3
.       hide item B_ADD4
.       hide item NEWKEY3
.       hide item NEWKEY3L
.       hide item NEWKEY3E
.       hide item NEWKEY3H
.       hide item B_ADD4
.       hide item NEWKEY4
.       hide item NEWKEY4L
.       hide item NEWKEY4E
.       hide item NEWKEY4H
.     elseif (nkeys(REC_#) = 3)
.       hide item B_ADD1
.       hide item B_ADD2
.       hide item B_ADD4
.       hide item NEWKEY4
.       hide item NEWKEY4L
.       hide item NEWKEY4E
.       hide item NEWKEY4H
.     elseif (nkeys(REC_#) = 4)
.       hide item B_ADD1
.       hide item B_ADD2
.       hide item B_ADD3
.     endif
.     HOWMANY# = 0  | TOTAL COUNT OF HOW MANY ITEMS ARE APPENDED TO A LIST
.     for OURKEY#=1,nkeys(REC_#)
.       KEY$N   = keyname(REC_#, (OURKEY#+1))
.       LAB_CNT = nvallab(REC_#, KEY$N)
.       KEYMIN  = nmin   (REC_#, KEY$N)          | The minimum range of the key, if there is one
.       KEYMAX  = nmax   (REC_#, KEY$N)          | The maximum range of the key, if there is one
.       VTYPE_# = vtype  (REC_#, KEY$N)
.       TXT$ = format(OURKEY#)+ ". Enter a new "
.       ifthen (len(pack(varlabsc(REC_#,KEY$N))) gt 0 )
.         TXT$ = TXT$ + pack(varlabsc(REC_#,KEY$N))
.       else
.         TXT$ = TXT$ + KEY$N
.       endif
.       if ( OURKEY#  = 1) D_ITEM_# = NEWKEY1;  set item NEWKEY1L, TXT$ ; enable item NEWKEY1
.       if ( OURKEY#  = 2) D_ITEM_# = NEWKEY2;  set item NEWKEY2L, TXT$ ; enable item NEWKEY2
.       if ( OURKEY#  = 3) D_ITEM_# = NEWKEY3;  set item NEWKEY3L, TXT$ ; enable item NEWKEY3
.       if ( OURKEY#  = 4) D_ITEM_# = NEWKEY4;  set item NEWKEY4L, TXT$ ; enable item NEWKEY4
.         TXT$ = ''
.       ifthen (VTYPE_# = 3)
.         TXT$ = substr( vformat(REC_#,key$n),2,len(vformat(REC_#,key$n)))
.         TXT$ = replace(TXT$ ,':','/',4,1,0)
.       elseif (VTYPE_# = 4)
.         TXT$ = substr( vformat(REC_#,key$n),2,len(vformat(REC_#,key$n)))
.       endif
.       if ( OURKEY#  = 1) set item NEWKEY1H,TXT$
.       if ( OURKEY#  = 2) set item NEWKEY2H,TXT$
.       if ( OURKEY#  = 3) set item NEWKEY3H,TXT$
.       if ( OURKEY#  = 4) set item NEWKEY4H,TXT$
c ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc
.       ifthen (nvalid(REC_#, KEY$N) ne 0 and LAB_CNT = 0) | Valid values without labels
.         VALID_# = 0
.         for VALID_# = 1, nvalid(REC_#, KEY$N)
.           append item D_ITEM_#, pad(format(nvval(REC_#, KEY$N, VALID_#)),' ',3,3)
.         end for
.       elseif (vtype(REC_#, KEY$N) = 2)                    | Categorical
.         VALID_# = 0
.         while (VALID_# lt LAB_CNT)                        | Use the categorical value after appending its numeric value in front...
.           VALID_# = VALID_# + 1
.           append item D_ITEM_#, pad(format(VALID_#),' ',3,3) + pad(pack(vallabsv(REC_#, KEY$N, VALID_#)),' ',3,3) + ' ' + pack(vallabsn(REC_#, KEY$N, VALID_#))
.         end while
.       elseif (LAB_CNT gt 0)                              | Value labels. If there are labels, use them...
.         VALID_# = 0
.         while (VALID_# lt LAB_CNT)
.           VALID_# = VALID_# + 1
.           append item D_ITEM_#, pad(pack(vallabsv(REC_#, KEY$N, VALID_#)),' ',3,3) + ' ' + pack(vallabsn(REC_#, KEY$N, VALID_#))
.         end while
.       elseif ((KEYMAX - KEYMIN) le 1000)                   | If there aren't labels but there is a reasonable range, use that...
.         for MINTOMAX = KEYMIN, KEYMAX
.           append item D_ITEM_#, format(MINTOMAX)
.         end for
.       else                  | If you get here, then check the record for actual values, unless the previous key was a Q_MARK mark.
.         hide item D_ITEM_#
.       endif
.       HOWMANY# = HOWMANY#+getnitem(D_ITEM_#)
.     end for
.     ifthen (HOWMANY# = 0)
.       hide item SELECTL
.     endif
.   end initial
.   message ALL m_id, m_arg1, m_arg2
.     ifthen (m_id = B_ADD1 or B_ADD2 or B_ADD3 or B_ADD4 )
.       execute subprocedure TEST_VALUES
.       ifthen (PASSCHCK = 1)  |Passed all the checks!
.         PASSKEY1E = gettxt(NEWKEY1E)
.         PASSKEY2E = gettxt(NEWKEY2E)
.         PASSKEY3E = gettxt(NEWKEY3E)
.         PASSKEY4E = gettxt(NEWKEY4E)
.         exit message  | make sure you exit back to main navigation screen
.       endif
.     endif
.     ifthen (m_id = CANCEL_X)  |I'm going to use the Cancel box as the default button to see where the user is.
.       ifthen (GETFOCUS(0) = 1)
.         exit message
.       elseif (getfocus(0) = NEWKEY1E)
.         focus item NEWKEY2E
.         if (nkeys(REC_#) = 1) focus item B_ADD1
.       elseif (getfocus(0) = NEWKEY2E)
.         focus item NEWKEY3E
.         if (nkeys(REC_#) = 2) focus item B_ADD2
.       elseif (getfocus(0) = NEWKEY3E)
.         focus item NEWKEY4E
.         if (nkeys(REC_#) = 3) focus item B_ADD3
.       elseif (getfocus(0) = NEWKEY4E)
.         focus item B_ADD1
.         if (nkeys(REC_#) = 4) focus item B_ADD4
.       elseif (getfocus(0) = B_ADD1 OR B_ADD2 OR B_ADD3 OR B_ADD4)
.         execute subprocedure TEST_VALUES
.         ifthen (PASSCHCK = 1)  |Passed all the checks!
.           PASSKEY1E = gettxt(NEWKEY1E)
.           PASSKEY2E = gettxt(NEWKEY2E)
.           PASSKEY3E = gettxt(NEWKEY3E)
.           PASSKEY4E = gettxt(NEWKEY4E)
.           exit message  | make sure you exit back to main navigation screen
.         endif
.       endif
.     endif
.     ifthen (m_id = NEWKEY1)
.       set item NEWKEY1E,gettxt(NEWKEY1)
.       focus item NEWKEY2E
.     endif
.     ifthen (m_id = NEWKEY2)
.       set item NEWKEY2E,gettxt(NEWKEY2)
.       focus item NEWKEY3E
.     endif
.     ifthen (m_id = NEWKEY3)
.       set item NEWKEY3E,gettxt(NEWKEY3)
.       focus item NEWKEY4E
.     endif
.     ifthen (m_id = NEWKEY4)
.       set item NEWKEY4E,gettxt(NEWKEY4)
.     endif
.     if (m_id = 0) exit message
.   end message
. end dialog
end subprocedure
|
|
subprocedure TEST_VALUES  |IT RETURNS PASSCHCK = 1 GOOD KEYS
<comment> write 'subprocedure TEST_VALUES'
. for OURKEY#=1,nkeys(REC_#)
.   PASSCHCK = 1  |lets assume everything is all right.
.   KEY$N   = keyname(REC_#, (OURKEY#+ dbtype(0)))
.   if ( OURKEY#  = 1) KEY$V = gettxt(NEWKEY1E)
.   if ( OURKEY#  = 2) KEY$V = gettxt(NEWKEY2E)
.   if ( OURKEY#  = 3) KEY$V = gettxt(NEWKEY3E)
.   if ( OURKEY#  = 4) KEY$V = gettxt(NEWKEY4E)
string * 30 CAT$V  | 2. Temporary solution for handling CAT VARS
.   CAT$V = trimlr(sbst(KEY$V, abs(srst(KEY$V,' ')),3))
c write "Cat " CAT$V
.   POS = abs(srst(KEY$V, ' '))-1  | A space indicates that value labels were added
.   if (POS < 0) POS = len(KEY$V)
.   KEY$V = sbst(KEY$V, 1, POS)
.   ifthen (vtype(REC_#,KEY$N) = 1)  | string
.     if then (numbr(substr(vformat(REC_#,KEY$N),1,len(vformat(REC_#,KEY$N)))) gt len(KEY$V))
.       display infobox "Stop!  "+KEY$N+ ' That is too long'
.       PASSCHCK = 0
.     end if
.   else if (vtype(REC_#,KEY$N) = 2)  | categorical
.      GOODCAT = 0
.     for N=1,nvalid(REC_#,KEY$N)  |must cycle thru and get values instead of use "catint"
c write "Checking svval " [svval(REC_#,KEY$N, N )] "Key value " KEY$V
.       if (svval(REC_#,KEY$N, N ) =  CAT$V )   GOODCAT=1; exit for    |VALID VALUE 2.
.     end for
.     if then (GOODCAT = 0)
.       display infobox "1. Stop!  "+KEY$N+ " cannot be equal to that."
.       PASSCHCK=0
.     end if
.   else if (vtype(REC_#,KEY$N) = 3)  |its a date so check the format.
.     TYPEDATE = datemap(REC_#,KEY$N)
.     TYPEDATE = replace(TYPEDATE,'E','',1,1,0)
.     TYPEDATE = replace(TYPEDATE,'M','d',4,1,0)
.     TYPEDATE = replace(TYPEDATE,'D','d',4,1,0)
.     TYPEDATE = replace(TYPEDATE,'Y','d',4,1,0)
.     TYPEDATE = replace(TYPEDATE,'/','x',4,1,0)
.     TYPEDATE = replace(TYPEDATE,'I','x',4,1,0)
.     if (picture(KEY$V,TYPEDATE) ne 0) PASSCHCK=0
.     if (PASSCHCK = 0) display infobox "Stop!  " + KEY$N + " is "+ datemap(REC_#,KEY$N)
.   else if (vtype(REC_#,KEY$N) = 4)  |its a date so check the format.
.     TYPETIME = timemap(REC_#,KEY$N)
.     TYPETIME = replace(TYPETIME,'H','d',4,1,0)
.     TYPETIME = replace(TYPETIME,'M','d',4,1,0)
.     TYPETIME = replace(TYPETIME,'S','d',4,1,0)
.     TYPETIME = replace(TYPETIME,':','x',4,1,0)
.     TYPETIME = replace(TYPETIME,'I','x',4,1,0)
.     if (picture(KEY$V,TYPETIME) ne 0)  PASSCHCK=0
.     if (PASSCHCK = 0) display infobox "Stop!  "+KEY$N + " is "+ timemap(REC_#,KEY$N)
.   else if (vtype(REC_#,KEY$N) = 5 or 6 or 7 or 8)  |its an integer
c     write "This is it! " [format(numbr(KEY$V))]
.     ifthen (exists(numbr(KEY$V)) = 0)
.       display infobox "Stop!  "+KEY$N+ "must be a number!"
.       PASSCHCK = 0
.     else if (nmax(REC_#,KEY$N) lt numbr(KEY$V))
.       PASSCHCK = 0
.       display infobox "Stop!  "+KEY$N+ " must be below "+format(nmax(REC_#,KEY$N))
.     else if (nmin(REC_#,KEY$N) gt numbr(KEY$V))
.       PASSCHCK = 0
.       display infobox "Stop!  "+KEY$N+ " must be above "+format(nmin(REC_#,KEY$N))
.     end if
.   end if
.   ifthen (len(KEY$V) GT 44)
.     PASSCHCK = 0
.     display infobox "Stop!  "+KEY$N+ " Shoot D.B.A."
.   end if
.   ifthen (vtype(REC_#,KEY$N) = 2)  | catagorical
.     ifthen (validate (REC_#, KEY$N,svval(REC_#,KEY$N, N)) NE 0)
.       PASSCHCK = 0
.       display infobox "Stop!  "+KEY$N+ " cannot be that value. (Cat. Var.)"
.     endif
.     else
.     ifthen (validate (REC_#, KEY$N,KEY$V) NE 0)
.       PASSCHCK = 0
.       display infobox "2. Stop!  "+KEY$N+ " cannot be that value."
.     endif
.   endif
.   ifthen (PASSCHCK = 1)  |Passed all the checks!
.     if(OURKEY# = 1) KEY$1 = KEY$V
.     if(OURKEY# = 2) KEY$2 = KEY$V
.     if(OURKEY# = 3) KEY$3 = KEY$V
.     if(OURKEY# = 4) KEY$4 = KEY$V
.   elseif (PASSCHCK = 0)
c     it proved that something was bad!
.     if(OURKEY# = 1) focus item NEWKEY1E
.     if(OURKEY# = 2) focus item NEWKEY2E
.     if(OURKEY# = 3) focus item NEWKEY3E
.     if(OURKEY# = 4) focus item NEWKEY4E
.     exit subprocedure  |IMPORTANT otherwise you might get a PASSCHCK = 1 on the LAST KEY VALUE!  BIG BIG OPPS.
.   endif
. end for
end subprocedure
|
|
subprocedure VAR_LIST_APPEND
. remove all VAR_LIST
. ifthen (abs(srst(gettxt(FORMS),' ')) gt 0)   | Get the record number
.   REC_#  = recnum(trimlr(sbst(gettxt(FORMS),1,abs(srst(gettxt(FORMS),' ')))))
. else
.   REC_#  = recnum(trimlr(gettxt(FORMS)))
. endif
. for XVARS = 1,nvars(REC_#)
.   append item VAR_LIST, varname(REC_#,XVARS) + ':   ' + varlabsc(REC_#,varname(REC_#,XVARS))
. end for
end subprocedure
|
|
subprocedure SHOW_KEYS
. execute subprocedure HIDEALL
. ifthen (KEY#C eq 4)
.   show item KEY4
.   show item KEY3
.   show item KEY2
.   show item KEY1
.   show item KEY4L
.   show item KEY3L
.   show item KEY2L
.   show item KEY1L
.   set item KEY4L, pack(varlabsc(REC_#, keyname(REC_#,4 +dbtype(0)) ))
.   set item KEY3L, pack(varlabsc(REC_#, keyname(REC_#,3 +dbtype(0)) ))
.   set item KEY2L, pack(varlabsc(REC_#, keyname(REC_#,2 +dbtype(0)) ))
.   set item KEY1L, pack(varlabsc(REC_#, keyname(REC_#,1 +dbtype(0)) ))
. elseif (KEY#C eq 3)
.   show item KEY3
.   show item KEY2
.   show item KEY1
.   show item KEY3L
.   show item KEY2L
.   show item KEY1L
.   set item KEY3L, pack(varlabsc(REC_#, keyname(REC_#,3 +dbtype(0)) ))
.   set item KEY2L, pack(varlabsc(REC_#, keyname(REC_#,2 +dbtype(0)) ))
.   set item KEY1L, pack(varlabsc(REC_#, keyname(REC_#,1 +dbtype(0)) ))
. elseif (KEY#C eq 2)
.   show item KEY2
.   show item KEY1
.   show item KEY2L
.   show item KEY1L
.   set item KEY2L, pack(varlabsc(REC_#, keyname(REC_#,2 +dbtype(0)) ))
.   set item KEY1L, pack(varlabsc(REC_#, keyname(REC_#,1 +dbtype(0)) ))
. elseif (KEY#C eq 1)
.   show item KEY1
.   show item KEY1L
.   set item KEY1L, pack(varlabsc(REC_#, keyname(REC_#,1 +dbtype(0)) ))
. endif
end subprocedure
|
|
subprocedure SELECTED_KEYS
.  write(seach_pql)     '.     JOURN_SELECT = 1'  | Start with all records matching and then weed out the ones that DO NOT MATCH.
.  ifthen (len(trim(gettxt(KEY0))) gt 0)
.    MONKEYLINE = '.     ifNOT ("' + gettxt(KEY0) +'" = ' + 'trim(varget("' + trim(keyname(REC_#,0 +dbtype(0))) + '"))) JOURN_SELECT = 0'
.    write(seach_pql) MONKEYLINE
.  endif
.  ifthen (len(trim(gettxt(KEY1))) gt 0)
.    MONKEYLINE = '.     ifNOT ("' + gettxt(KEY1) +'" = ' + 'trim(varget("' + trim(keyname(REC_#,1 +dbtype(0))) + '"))) JOURN_SELECT = 0'
.    write(seach_pql) MONKEYLINE
.  endif
.  ifthen (len(trim(gettxt(KEY2))) gt 0)
.    MONKEYLINE = '.     ifNOT ("' + gettxt(KEY2) +'" = ' + 'trim(varget("' + trim(keyname(REC_#,2 +dbtype(0))) + '"))) JOURN_SELECT = 0'
.    write(seach_pql) MONKEYLINE
.  endif
.  ifthen (len(trim(gettxt(KEY3))) gt 0)
.    MONKEYLINE = '.     ifNOT ("' + gettxt(KEY3) +'" = ' + 'trim(varget("' + trim(keyname(REC_#,3 +dbtype(0))) + '"))) JOURN_SELECT = 0'
.    write(seach_pql) MONKEYLINE
.  endif
.  ifthen (len(trim(gettxt(KEY4))) gt 0)
.    MONKEYLINE = '.     ifNOT ("' + gettxt(KEY4) +'" = ' + 'trim(varget("' + trim(keyname(REC_#,4 +dbtype(0))) + '"))) JOURN_SELECT = 0'
.    write(seach_pql) MONKEYLINE
.  endif
c .  write(seach_pql)     '.     write JOURN_SELECT [varget("' [trim(keyname(REC_#,0 +dbtype(0)))] '")]'
.  write(seach_pql)     '.     if (JOURN_SELECT = 0) NEXT PROCESS JOURNAL'
end subprocedure
end program
|}
END PROCEDURE
